<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面试题合集-VUE, STAYAWAKE">
    <meta name="description" content="VUE2面试题系类1、v-show与v-if有什么区别？相同点：v-show和v-if都是控制dom元素的显示和隐藏。不同点：1、原理：v-show时通过控制元素的样式属性display的值，来完成显示和隐藏；v-if是通过对dom元素的添">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>面试题合集-VUE | STAYAWAKE</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <span class="logo-span">STAYAWAKE</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <div class="logo-name">STAYAWAKE</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/stayAwake9/stayAwake9.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/stayAwake9/stayAwake9.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/20.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面试题合集-VUE</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">
                                <span class="chip bg-color">面试题</span>
                            </a>
                        
                            <a href="/tags/VUE/">
                                <span class="chip bg-color">VUE</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-01-27
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    54 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="VUE2面试题系类"><a href="#VUE2面试题系类" class="headerlink" title="VUE2面试题系类"></a>VUE2面试题系类</h1><h2 id="1、v-show与v-if有什么区别？"><a href="#1、v-show与v-if有什么区别？" class="headerlink" title="1、v-show与v-if有什么区别？"></a>1、v-show与v-if有什么区别？</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><h5 id="v-show和v-if都是控制dom元素的显示和隐藏。"><a href="#v-show和v-if都是控制dom元素的显示和隐藏。" class="headerlink" title="v-show和v-if都是控制dom元素的显示和隐藏。"></a>v-show和v-if都是控制dom元素的显示和隐藏。</h5><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><h5 id="1、原理："><a href="#1、原理：" class="headerlink" title="1、原理："></a>1、原理：</h5><h5 id="v-show时通过控制元素的样式属性display的值，来完成显示和隐藏；"><a href="#v-show时通过控制元素的样式属性display的值，来完成显示和隐藏；" class="headerlink" title="v-show时通过控制元素的样式属性display的值，来完成显示和隐藏；"></a>v-show时通过控制元素的样式属性display的值，来完成显示和隐藏；</h5><h5 id="v-if是通过对dom元素的添加和删除来完成显示和隐藏"><a href="#v-if是通过对dom元素的添加和删除来完成显示和隐藏" class="headerlink" title="v-if是通过对dom元素的添加和删除来完成显示和隐藏"></a>v-if是通过对dom元素的添加和删除来完成显示和隐藏</h5><h5 id="2、使用场景：由原理（做法）得出使用场景的区别"><a href="#2、使用场景：由原理（做法）得出使用场景的区别" class="headerlink" title="2、使用场景：由原理（做法）得出使用场景的区别"></a>2、使用场景：由原理（做法）得出使用场景的区别</h5><h5 id="v-show：使用在dom元素频繁切换的场景"><a href="#v-show：使用在dom元素频繁切换的场景" class="headerlink" title="v-show：使用在dom元素频繁切换的场景"></a>v-show：使用在dom元素频繁切换的场景</h5><h5 id="v-if：当dom元素的切换不频繁，可以使用。特别是，首次元素处于隐藏的情况下"><a href="#v-if：当dom元素的切换不频繁，可以使用。特别是，首次元素处于隐藏的情况下" class="headerlink" title="v-if：当dom元素的切换不频繁，可以使用。特别是，首次元素处于隐藏的情况下"></a>v-if：当dom元素的切换不频繁，可以使用。特别是，首次元素处于隐藏的情况下</h5><hr>
<h2 id="2、说说对SPA单页面的理解，他的优缺点分别是什么？"><a href="#2、说说对SPA单页面的理解，他的优缺点分别是什么？" class="headerlink" title="2、说说对SPA单页面的理解，他的优缺点分别是什么？"></a>2、说说对SPA单页面的理解，他的优缺点分别是什么？</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><p>SPA的英文是 single-page application，也就是说整个项目中只有一个页面。</p>
<p>单页面应用的实现思路： 就是Web页面初始化时加载所有的HTML、JavaScript和 CSS，内容的变化，靠动态操作DOM。</p>
<h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><h6 id="1）：局部刷新。—用户体验好、快，内容的改变不需要重新加载整个页面。"><a href="#1）：局部刷新。—用户体验好、快，内容的改变不需要重新加载整个页面。" class="headerlink" title="1）：局部刷新。—用户体验好、快，内容的改变不需要重新加载整个页面。"></a>1）：局部刷新。—用户体验好、快，内容的改变不需要重新加载整个页面。</h6><h6 id="2）：服务器的压力小。-—-基于上面一点，SPA对服务器压力小；"><a href="#2）：服务器的压力小。-—-基于上面一点，SPA对服务器压力小；" class="headerlink" title="2）：服务器的压力小。  — 基于上面一点，SPA对服务器压力小；"></a>2）：服务器的压力小。  — 基于上面一点，SPA对服务器压力小；</h6><h6 id="3）：前后端职责分离。-—-架构清晰，前端进行交互逻辑，后端负责数据处理；"><a href="#3）：前后端职责分离。-—-架构清晰，前端进行交互逻辑，后端负责数据处理；" class="headerlink" title="3）：前后端职责分离。 — 架构清晰，前端进行交互逻辑，后端负责数据处理；"></a>3）：前后端职责分离。 — 架构清晰，前端进行交互逻辑，后端负责数据处理；</h6><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><h6 id="1）：初次加载耗时多。—-为实现单页面Web应用功能及显示效果，需要在加载页面的时候将，JavaScript、CSS统一加载，部分页面按需加载；"><a href="#1）：初次加载耗时多。—-为实现单页面Web应用功能及显示效果，需要在加载页面的时候将，JavaScript、CSS统一加载，部分页面按需加载；" class="headerlink" title="1）：初次加载耗时多。— 为实现单页面Web应用功能及显示效果，需要在加载页面的时候将，JavaScript、CSS统一加载，部分页面按需加载；"></a>1）：初次加载耗时多。— 为实现单页面Web应用功能及显示效果，需要在加载页面的时候将，JavaScript、CSS统一加载，部分页面按需加载；</h6><h6 id="2）：前进后退路由管理问题。-—-由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退的功能，所有的页面切换需要自己搭建堆栈管理（vue-router完成）"><a href="#2）：前进后退路由管理问题。-—-由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退的功能，所有的页面切换需要自己搭建堆栈管理（vue-router完成）" class="headerlink" title="2）：前进后退路由管理问题。 — 由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退的功能，所有的页面切换需要自己搭建堆栈管理（vue-router完成）"></a>2）：前进后退路由管理问题。 — 由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退的功能，所有的页面切换需要自己搭建堆栈管理（vue-router完成）</h6><h6 id="3）：SEO难度较大。—-由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。"><a href="#3）：SEO难度较大。—-由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。" class="headerlink" title="3）：SEO难度较大。— 由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。"></a>3）：SEO难度较大。— 由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。</h6><hr>
<h2 id="3、怎么理解Vue的单向数据流"><a href="#3、怎么理解Vue的单向数据流" class="headerlink" title="3、怎么理解Vue的单向数据流"></a>3、怎么理解Vue的单向数据流</h2><h4 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h4><h5 id="单项数据流是发生在-父组件向子组件传值的时候-，所有的prop使得起父子prop之间形成了一个单向下行绑定。"><a href="#单项数据流是发生在-父组件向子组件传值的时候-，所有的prop使得起父子prop之间形成了一个单向下行绑定。" class="headerlink" title="单项数据流是发生在   父组件向子组件传值的时候  ，所有的prop使得起父子prop之间形成了一个单向下行绑定。"></a>单项数据流是发生在   <em><strong>父组件向子组件传值的时候</strong></em>  ，所有的prop使得起父子prop之间形成了一个单向下行绑定。</h5><h5 id="也就是说：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态。"><a href="#也就是说：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态。" class="headerlink" title="也就是说：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态。"></a>也就是说：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态。</h5><h4 id="而且"><a href="#而且" class="headerlink" title="而且"></a>而且</h4><h5 id="每次父组件发生更新时，子组件中所有的prop都会刷新为最新的值。所以，在一个子组件内部改变prop，Vue会在浏览器的控制台发出警告。"><a href="#每次父组件发生更新时，子组件中所有的prop都会刷新为最新的值。所以，在一个子组件内部改变prop，Vue会在浏览器的控制台发出警告。" class="headerlink" title="每次父组件发生更新时，子组件中所有的prop都会刷新为最新的值。所以，在一个子组件内部改变prop，Vue会在浏览器的控制台发出警告。"></a>每次父组件发生更新时，子组件中所有的prop都会刷新为最新的值。所以，在一个子组件内部改变prop，Vue会在浏览器的控制台发出警告。</h5><hr>
<h2 id="4、computed和watch的区别和运用的场景？"><a href="#4、computed和watch的区别和运用的场景？" class="headerlink" title="4、computed和watch的区别和运用的场景？"></a>4、computed和watch的区别和运用的场景？</h2><h3 id="首先（相同点）："><a href="#首先（相同点）：" class="headerlink" title="首先（相同点）："></a>首先（相同点）：</h3><h6 id="computed-和-watch都可以实现数据的监听。"><a href="#computed-和-watch都可以实现数据的监听。" class="headerlink" title="computed 和 watch都可以实现数据的监听。"></a>computed 和 watch都可以实现数据的监听。</h6><h3 id="其次（区别）："><a href="#其次（区别）：" class="headerlink" title="其次（区别）："></a>其次（区别）：</h3><h5 id="第一（本质）："><a href="#第一（本质）：" class="headerlink" title="第一（本质）："></a>第一（本质）：</h5><p><strong>computed：是计算属性</strong>，依赖其他属性值，并且computed的值<strong>有缓存</strong>，当依赖的属性值发生改变时，才会重新计算computed的值，它可以设置getter和setter。</p>
<p><strong>watch：</strong>更多的是<strong>观察</strong>的作用，每当监听的数据变化都会执行回调进行后续操作，他只能设置getter.</p>
<h5 id="第二（运用场景）："><a href="#第二（运用场景）：" class="headerlink" title="第二（运用场景）："></a>第二（运用场景）：</h5><p><strong>computed：</strong>当我们需要进行数值计算，并且依赖于其他数据时，使用computed。</p>
<p><strong>watch：</strong>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch。</p>
<hr>
<h2 id="5、直接用下标（索引）给一个数组项赋值，Vue能检测到变化吗？"><a href="#5、直接用下标（索引）给一个数组项赋值，Vue能检测到变化吗？" class="headerlink" title="5、直接用下标（索引）给一个数组项赋值，Vue能检测到变化吗？"></a>5、直接用下标（索引）给一个数组项赋值，Vue能检测到变化吗？</h2><h3 id="不能。"><a href="#不能。" class="headerlink" title="不能。"></a>不能。</h3><h5 id="因为，vue在做数据劫持时，只对数组做了劫持，没有对数组的每一项进行劫持。所以用下标的方式修改数组时，vue不能检测到数据的变化。"><a href="#因为，vue在做数据劫持时，只对数组做了劫持，没有对数组的每一项进行劫持。所以用下标的方式修改数组时，vue不能检测到数据的变化。" class="headerlink" title="因为，vue在做数据劫持时，只对数组做了劫持，没有对数组的每一项进行劫持。所以用下标的方式修改数组时，vue不能检测到数据的变化。"></a>因为，vue在做数据劫持时，只对数组做了劫持，没有对数组的每一项进行劫持。所以用下标的方式修改数组时，vue不能检测到数据的变化。</h5><h5 id="为了解决他们，Vue也提供了操作方法：Vue-set"><a href="#为了解决他们，Vue也提供了操作方法：Vue-set" class="headerlink" title="为了解决他们，Vue也提供了操作方法：Vue.set"></a>为了解决他们，Vue也提供了操作方法：Vue.set</h5><h5 id="Vue-set（数组名，下标，新值）"><a href="#Vue-set（数组名，下标，新值）" class="headerlink" title="Vue.set（数组名，下标，新值）"></a>Vue.set（数组名，下标，新值）</h5><hr>
<h1 id="6、谈谈对Vue生命周期的理解？"><a href="#6、谈谈对Vue生命周期的理解？" class="headerlink" title="6、谈谈对Vue生命周期的理解？"></a>6、谈谈对Vue生命周期的理解？</h1><h3 id="1）、生命周期是什么？"><a href="#1）、生命周期是什么？" class="headerlink" title="1）、生命周期是什么？"></a>1）、生命周期是什么？</h3><h6 id="Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载DOM–-gt-渲染、更新—-gt-渲染、卸载等一系列过程，我们称这是Vue生命周期。"><a href="#Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载DOM–-gt-渲染、更新—-gt-渲染、卸载等一系列过程，我们称这是Vue生命周期。" class="headerlink" title="Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载DOM–>渲染、更新—>渲染、卸载等一系列过程，我们称这是Vue生命周期。"></a>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载DOM–&gt;渲染、更新—&gt;渲染、卸载等一系列过程，我们称这是Vue生命周期。</h6><h3 id="2）、各个生命周期阶段及其钩子函数"><a href="#2）、各个生命周期阶段及其钩子函数" class="headerlink" title="2）、各个生命周期阶段及其钩子函数"></a>2）、各个生命周期阶段及其钩子函数</h3><h5 id="Vue的生命周期核心经历了四个阶段，在四个阶段的前后分别由两个钩子函数。"><a href="#Vue的生命周期核心经历了四个阶段，在四个阶段的前后分别由两个钩子函数。" class="headerlink" title="Vue的生命周期核心经历了四个阶段，在四个阶段的前后分别由两个钩子函数。"></a>Vue的生命周期核心经历了四个阶段，在四个阶段的前后分别由两个钩子函数。</h5><h6 id="第一阶段：-数据挂载阶段：把配置项data中的属性，赋给了vue对象本身，并且做了数据劫持。"><a href="#第一阶段：-数据挂载阶段：把配置项data中的属性，赋给了vue对象本身，并且做了数据劫持。" class="headerlink" title="第一阶段： 数据挂载阶段：把配置项data中的属性，赋给了vue对象本身，并且做了数据劫持。"></a>第一阶段： 数据挂载阶段：把配置项data中的属性，赋给了vue对象本身，并且做了数据劫持。</h6><p>该阶段前后的两个钩子函数： beforeCreate 和  created</p>
<h6 id="第二阶段：模板渲染阶段：把vue对象的数据渲染到模板上。"><a href="#第二阶段：模板渲染阶段：把vue对象的数据渲染到模板上。" class="headerlink" title="第二阶段：模板渲染阶段：把vue对象的数据渲染到模板上。"></a>第二阶段：模板渲染阶段：把vue对象的数据渲染到模板上。</h6><p>该阶段前后的两个钩子函数：beforeMount 和  mounted</p>
<h6 id="第三阶段：组件更新阶段：当数据发送变化时，组件会进行重新渲染，所以，准确的说是，组件重新渲染阶段"><a href="#第三阶段：组件更新阶段：当数据发送变化时，组件会进行重新渲染，所以，准确的说是，组件重新渲染阶段" class="headerlink" title="第三阶段：组件更新阶段：当数据发送变化时，组件会进行重新渲染，所以，准确的说是，组件重新渲染阶段"></a>第三阶段：组件更新阶段：当数据发送变化时，组件会进行重新渲染，所以，准确的说是，组件重新渲染阶段</h6><p>该阶段前后的两个钩子函数：beforeUpdate 和 updated</p>
<h6 id="第四阶段：组件销毁阶段：组件销毁。"><a href="#第四阶段：组件销毁阶段：组件销毁。" class="headerlink" title="第四阶段：组件销毁阶段：组件销毁。"></a>第四阶段：组件销毁阶段：组件销毁。</h6><p>该阶段前后的两个钩子函数：beforeDestroy 和 destroyed</p>
<h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><h6 id="当使用keep-alive包裹组件时，会有组件激活和停用之说，这两个钩子函数分别是：activited-和-deactivated"><a href="#当使用keep-alive包裹组件时，会有组件激活和停用之说，这两个钩子函数分别是：activited-和-deactivated" class="headerlink" title="当使用keep-alive包裹组件时，会有组件激活和停用之说，这两个钩子函数分别是：activited  和  deactivated"></a>当使用keep-alive包裹组件时，会有组件激活和停用之说，这两个钩子函数分别是：activited  和  deactivated</h6><hr>
<h1 id="Vue生命周期详解"><a href="#Vue生命周期详解" class="headerlink" title="Vue生命周期详解"></a>Vue生命周期详解</h1><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/202104231514186151.png"></p>
<h4 id="使用Vue框架，需要再合适的时机做合适的事情，了解了Vue对象的生命周期和钩子函数，才能知道，哪些事情应该在哪个函数里做。"><a href="#使用Vue框架，需要再合适的时机做合适的事情，了解了Vue对象的生命周期和钩子函数，才能知道，哪些事情应该在哪个函数里做。" class="headerlink" title="使用Vue框架，需要再合适的时机做合适的事情，了解了Vue对象的生命周期和钩子函数，才能知道，哪些事情应该在哪个函数里做。"></a>使用Vue框架，需要再合适的时机做合适的事情，了解了Vue对象的生命周期和钩子函数，才能知道，哪些事情应该在哪个函数里做。</h4><h5 id="一、vue生命周期的理解"><a href="#一、vue生命周期的理解" class="headerlink" title="一、vue生命周期的理解"></a>一、vue生命周期的理解</h5><p>1、生命周期</p>
<p>用人举例：生命周期就是一个人的一生，从人的出生，到成长，到工作，到死亡，就是人的一生，也叫一个人的生命周期。</p>
<p>2、对象的生命周期</p>
<p>在程序开发中对象的生命周期就是：从对象的创建，到使用对象，到对象的消亡整个过程。</p>
<p>3、Vue的生命周期</p>
<p>Vue实例，Vue组件实例都是Vue对象，也是对象。所以，Vue的生命周期和对象的生命周期是同样的道理。</p>
<h5 id="二、Vue生命周期经历的阶段"><a href="#二、Vue生命周期经历的阶段" class="headerlink" title="二、Vue生命周期经历的阶段"></a>二、Vue生命周期经历的阶段</h5><p>Vue对象的生命周期也分不同的阶段，不同的阶段也可以做不同的事情，但是不同的vue（组件）对象在不同的阶段做的事情也不尽相同，所以，每个vue组件的代码不相同。</p>
<h6 id="Vue生命周期经历哪些阶段："><a href="#Vue生命周期经历哪些阶段：" class="headerlink" title="Vue生命周期经历哪些阶段："></a>Vue生命周期经历哪些阶段：</h6><p>1、总体来说：初始化、运行中、销毁</p>
<p>2、详细来说：开始创建、初始化数据、编译模板、挂载Dom、渲染–&gt;更新–&gt;渲染、销毁等一系列过程</p>
<h5 id="三、生命周期经历的阶段和钩子函数"><a href="#三、生命周期经历的阶段和钩子函数" class="headerlink" title="三、生命周期经历的阶段和钩子函数"></a>三、生命周期经历的阶段和钩子函数</h5><h6 id="1、实例化Vue（组件）对象：new-Vue"><a href="#1、实例化Vue（组件）对象：new-Vue" class="headerlink" title="1、实例化Vue（组件）对象：new   Vue()"></a>1、实例化Vue（组件）对象：new   Vue()</h6><h6 id="2、初始化事件和生命周期-init-events-和-init-cycle"><a href="#2、初始化事件和生命周期-init-events-和-init-cycle" class="headerlink" title="2、初始化事件和生命周期  init  events  和  init cycle"></a>2、初始化事件和生命周期  init  events  和  init cycle</h6><h6 id="3、beforeCreated函数："><a href="#3、beforeCreated函数：" class="headerlink" title="3、beforeCreated函数："></a>3、beforeCreated函数：</h6><p>在实例初始化之后，数据观测（data observer）和 event/watcher 事件配置之前被调用。</p>
<p>此时Vue（组件）对象被创建，但是Vue对象的属性还没有绑定，如果data属性，computed属性还没有绑定，即没有值。</p>
<p>此时还没有数据和真实DOM。即：属性还没有赋值，也没有动态创建template属性对应的HTML元素（二阶段的createUI海曙还没有执行）</p>
<h6 id="4、挂载数据（属性赋值）"><a href="#4、挂载数据（属性赋值）" class="headerlink" title="4、挂载数据（属性赋值）"></a>4、挂载数据（属性赋值）</h6><p>包括属性和computed的运算。</p>
<h6 id="5、Created函数："><a href="#5、Created函数：" class="headerlink" title="5、Created函数："></a>5、Created函数：</h6><p>Vue对象的属性有值了，但是DOM还没有生成，$el属性还不存在。此时有数据了，但是还没有真实DOM</p>
<p>即：data，computed都执了。属性已经赋值，但还没有动态创建template属性对应的HTML元素，所以，此时如果更改数据不会触发updated函数。</p>
<p>如果数据初始值就来自于后端，可以发送ajax。或者fetch请求数据。</p>
<h6 id="6、检查"><a href="#6、检查" class="headerlink" title="6、检查"></a>6、检查</h6><p>1）、检查是否有el属性</p>
<p>检查Vue配置，即new Vue()里面的el项是否存在，有就继续检查template项。没有则等到手动绑定调用 vm.$mount() </p>
<p>完成了全局变量$el的绑定。</p>
<p>2）、检查是否有template属性</p>
<p>检查配置中的template项，如果没有template进行填充被绑定区域，则被绑定区域的el对象的outerHtml（即整个#app DOM对象，包括 div id=”app”和div标签）都作为被填充对象替换掉填充区域</p>
<p>即：如果vue对象中有 template属性，那么，template后面的HTML会替换$el对应的内容。如果有render属性，那么render就会替换template。</p>
<p>即：优先关系时： render &gt; template &gt; el</p>
<h6 id="7、beforeMount函数："><a href="#7、beforeMount函数：" class="headerlink" title="7、beforeMount函数："></a>7、beforeMount函数：</h6><p>模板编译（template）数据挂载（把数据显示载模板里）之前执行的钩子函数。</p>
<p>此时this.$el有值但是数据还没挂载到页面上。即此时页面中的里的变量还没有被数据替换</p>
<h6 id="8、模板编译："><a href="#8、模板编译：" class="headerlink" title="8、模板编译："></a>8、模板编译：</h6><p>用Vue对象的数据（属性）替换模板中的内容</p>
<h6 id="9、Mounted函数："><a href="#9、Mounted函数：" class="headerlink" title="9、Mounted函数："></a>9、Mounted函数：</h6><p>模板编译完成，数据挂载完成</p>
<p>即：此时已经把数据挂载到了页面上，所以，页面上能够看到正确的数据了。</p>
<p>此处虽然也可以发送异步请求，但是没有created早，所以会显得比较缓慢，所以建议在 creatd里发送请求。</p>
<h6 id="10、beforeUpdated函数："><a href="#10、beforeUpdated函数：" class="headerlink" title="10、beforeUpdated函数："></a>10、beforeUpdated函数：</h6><p>组件更新之前执行的函数只有数据更新后，才能调用beforeUpdate，注意：此数据一定是在模板上出现的数据，并且改数据值修改前后不一样。否则，不会，也没有必要触发组件更新（因为数据不出现在模板里数据也灭有改变，就没有必要再次渲染）数据更新了，但是Vue（组件）对象对应的DOM中的内部（innerHTML）没有变，所以叫做组件更新前</p>
<h6 id="11、update函数："><a href="#11、update函数：" class="headerlink" title="11、update函数："></a>11、update函数：</h6><p>组件更新之后执行的函数</p>
<p>Vue（组件）对象对应的dom中的内部（innerHTML）改变了，所以叫做组更新之后</p>
<h6 id="12、activated函数："><a href="#12、activated函数：" class="headerlink" title="12、activated函数："></a>12、activated函数：</h6><p>keep-alive组件激活时调用</p>
<h6 id="13、deactivated函数："><a href="#13、deactivated函数：" class="headerlink" title="13、deactivated函数："></a>13、deactivated函数：</h6><p>keep-alive组件停用时调用</p>
<h6 id="14、beforeDestory："><a href="#14、beforeDestory：" class="headerlink" title="14、beforeDestory："></a>14、beforeDestory：</h6><p>Vue（组件）对象销毁之前。</p>
<p>在这个生命周期钩子函数里，可以销毁定时器，因为定时器时全局的，属于window对象的，所以，组件销毁时，并不会销毁定时器</p>
<h6 id="15、destroyed："><a href="#15、destroyed：" class="headerlink" title="15、destroyed："></a>15、destroyed：</h6><p>Vue组件销毁后</p>
<h5 id="四、测试代码："><a href="#四、测试代码：" class="headerlink" title="四、测试代码："></a>四、测试代码：</h5><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
  &lt;title&gt;vue生命周期学习&lt;/title&gt;
  &lt;/head&gt;
&lt;body&gt;
  &lt;div id="app"&gt;
    &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;h1&gt;count:{{count}}&lt;/h1&gt;
  &lt;/div&gt;
  &lt;input id="btn01" type="button" value="测试" /&gt;
&lt;/body&gt;
&lt;script type="text/javascript" src="js/vue.min.js" &gt;&lt;/script&gt;
&lt;script&gt;
  var vm = new Vue({
    el: '#app',
    data: {
      message: 'Vue的生命周期',
      age:2
    },
    computed:{
    	count:function(){
    		return this.age+1;
    	}
    },
//  template:"&lt;p&gt;vue对象中的template的内容&lt;/p&gt;",
//  render: function(createElement) {
//      return createElement('h1', 'this is createElement')
//  },
    beforeCreate: function() {
      console.group('------beforeCreate创建前状态------');
      console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined
      console.log("%c%s", "color:red","data   : " + this.$data); //undefined 
     console.log("%c%s", "color:red","count   : " + this.count); //undefined 
      console.log("%c%s", "color:red","message: " + this.message) 
    },
    created: function() {
      console.group('------created创建完毕状态------');
      console.log("%c%s", "color:red","el     : " + this.$el); //undefined
      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化 
      console.log("%c%s", "color:red","count   : " + this.count); //undefined 
      console.log("%c%s", "color:red","message: " + this.message); //已被初始化
    },
    //完成了el的绑定
    beforeMount: function() {
       console.group('------beforeMount挂载前状态------');
       console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化
       console.log(this.$el.innerHTML);    
       console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化  
       console.log("%c%s", "color:red","message: " + this.message); //已被初始化  
    },
    mounted: function() {
      console.group('------mounted 挂载结束状态------');
      console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化
      console.log(this.$el);    
      console.log(this.$el.innerHTML);    
      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化
      console.log("%c%s", "color:red","message: " + this.message); //已被初始化 
    },
    beforeUpdate: function () {
      console.group('beforeUpdate 更新前状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el.innerHTML);
      console.log("%c%s", "color:red","data   : " + this.$data.message); 
      console.log("%c%s", "color:red","message: " + this.message); 
    }
    ,
    updated: function () {
      console.group('updated 更新完成状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el.innerHTML);   
      console.log("%c%s", "color:red","data   : " + this.$data); 
      console.log("%c%s", "color:red","message: " + this.message); 
    },
//  beforeDestroy: function () {
//    console.group('beforeDestroy 销毁前状态===============》');
//    console.log("%c%s", "color:red","el     : " + this.$el);
//    console.log(this.$el);    
//    console.log("%c%s", "color:red","data   : " + this.$data); 
//    console.log("%c%s", "color:red","message: " + this.message); 
//  },
//  destroyed: function () {
//    console.group('destroyed 销毁完成状态===============》');
//    console.log("%c%s", "color:red","el     : " + this.$el);
//    console.log(this.$el);  
//    console.log("%c%s", "color:red","data   : " + this.$data); 
//    console.log("%c%s", "color:red","message: " + this.message)
//  }
  });
  
  document.getElementById("btn01").onclick = function(){
  		vm.message="改了";
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="五、模拟Vue的构造函数（部分代码）"><a href="#五、模拟Vue的构造函数（部分代码）" class="headerlink" title="五、模拟Vue的构造函数（部分代码）"></a>五、模拟Vue的构造函数（部分代码）</h5><p>myVue.js</p>
<pre class="line-numbers language-none"><code class="language-none">class MyVue{
	constructor(obj){
		//默认值
		let defaultObj={
		  data: null,
		  computed:null,
		  watch:null,
		  beforeCreate:function(){
			
		  },
		  created:function(){
			
		  },
		  beforeMount:function(){
			
		  },
		  mounted:function(){
			
		  }
		}
		for(let key in defaultObj){
			obj[key]?this[key]=obj[key]:this[key]=defaultObj[key];
		}
		
		//对象创建完毕已经有this了。
		this.beforeCreate();	
		//挂载数据：
		//1）、把传入的data属性的值赋给this
		if(obj.data){
			for(let key in this.data){
				this[key] = obj.data[key];
			}	
			this.$data = obj.data;//设置全局变量
		}
		//2）、计算属性		
		if(obj.computed){
			for(let key in obj.computed){
				this[key] = obj.computed[key].call(this);
			}
		}		
		//created函数
		this.created();
		//检查是否有el属性
		if(obj.el){
			this.el = $(obj.el);
			this.$el = $(obj.el);//设置全局变量
		}
		//检查是否有template属性
		if(this.template){
			//this.template = obj.template;
//			动态创建template 里所有的html元素
		}
		//beforeMonute
		this.beforeMount();
		//用vue对象的数据（属性）替换模板中的内容
		//1)、替换data中的数据
		let html = this.el.innerHTML;				
		for(let key in this.data){
			//用属性值替换，属性名（页面上用双花括号包起来的）
			html=html.replace(new RegExp("{{"+key+"}}","g"),this[key]);
		}	
		//2)、替换computed中的数据				
		for(let key in this.computed){
			//用属性值替换，属性名（页面上用双花括号包起来的）
			html=html.replace(new RegExp("{{"+key+"}}","g"),this[key]);
		}	
		this.el.innerHTML = html;
		
		//mounted函数：
		this.mounted();
	}
	
	addWatch(){
		
	}
	
	//数据双向绑定
	
	//
}
 
function $(str){//#box .cls  p
	if(str.charAt(0)=="#"){
		return document.getElementById(str.substring(1));
	}else if(str.charAt(0)=="."){
		return document.getElementsByClassName(str.substring(1));
	}else{
		return document.getElementsByTagName(str);
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>html代码：</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;

  &lt;div id="app"&gt;

    &lt;h1&gt;{{message}}&lt;/h1&gt;

    &lt;h1&gt;count:{{count}}&lt;/h1&gt;

  &lt;/div&gt;

&lt;/body&gt;

&lt;script type="text/javascript" src="js/myvue.js" &gt;&lt;/script&gt;

&lt;script&gt;

  var vm = new MyVue({

    el: '#app',

    data: {

      message: 'Vue的生命周期',

      age:1

    },

    computed:{

        count:function(){

           return this.age+1;

        }

    },

    beforeCreate: function() {

      console.group('------beforeCreate创建前状态------');

      console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined

      console.log("%c%s", "color:red","data   : " + this.$data); //undefined

      console.log("%c%s", "color:red","message: " + this.message)

    },

    created: function() {

      console.group('------created创建完毕状态------');

      console.log("%c%s", "color:red","el     : " + this.$el); //undefined

      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化

      console.log("%c%s", "color:red","message: " + this.message); //已被初始化

    },

    //完成了el的绑定

    beforeMount: function() {

       console.group('------beforeMount挂载前状态------');

       console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化

       console.log(this.$el);

       console.log(this.$el.innerHTML);   

       console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化 

       console.log("%c%s", "color:red","message: " + this.message); //已被初始化 

    },

    mounted: function() {

      console.group('------mounted 挂载结束状态------');

      console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化

      console.log(this.$el);   

      console.log(this.$el.innerHTML);   

      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化

      console.log("%c%s", "color:red","message: " + this.message); //已被初始化

    }   

  })<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="7、Vue的父组件和子组件生命周期钩子函数执行顺序？"><a href="#7、Vue的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="7、Vue的父组件和子组件生命周期钩子函数执行顺序？"></a>7、Vue的父组件和子组件生命周期钩子函数执行顺序？</h2><h3 id="Vue的父子组件钩子函数的执行顺序可以归类为4个部分："><a href="#Vue的父子组件钩子函数的执行顺序可以归类为4个部分：" class="headerlink" title="Vue的父子组件钩子函数的执行顺序可以归类为4个部分："></a>Vue的父子组件钩子函数的执行顺序可以归类为4个部分：</h3><h5 id="第一部分：首次加载渲染"><a href="#第一部分：首次加载渲染" class="headerlink" title="第一部分：首次加载渲染"></a>第一部分：首次加载渲染</h5><h6 id="父-beforeCreated-gt-父-created-gt-父-beforeMount-gt-子-beforeCreate-gt-子-created-gt-子-beforeMount-gt-子-mounted-gt-父-mounted"><a href="#父-beforeCreated-gt-父-created-gt-父-beforeMount-gt-子-beforeCreate-gt-子-created-gt-子-beforeMount-gt-子-mounted-gt-父-mounted" class="headerlink" title="父 beforeCreated->父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted"></a>父 beforeCreated-&gt;父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</h6><h5 id="第二部分：父组件修改子组件的props值时："><a href="#第二部分：父组件修改子组件的props值时：" class="headerlink" title="第二部分：父组件修改子组件的props值时："></a>第二部分：父组件修改子组件的props值时：</h5><h6 id="父-beforeUpdate-gt-子-beforeUpdate-gt-子-updated-gt-父-updated"><a href="#父-beforeUpdate-gt-子-beforeUpdate-gt-子-updated-gt-父-updated" class="headerlink" title="父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated"></a>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</h6><h5 id="第三部分：父组件修改的数据跟子组件没有关系时："><a href="#第三部分：父组件修改的数据跟子组件没有关系时：" class="headerlink" title="第三部分：父组件修改的数据跟子组件没有关系时："></a>第三部分：父组件修改的数据跟子组件没有关系时：</h5><h6 id="不会影响子组件-父-beforeUpdate-gt-父-updated"><a href="#不会影响子组件-父-beforeUpdate-gt-父-updated" class="headerlink" title="不会影响子组件 父 beforeUpdate -> 父 updated"></a>不会影响子组件 父 beforeUpdate -&gt; 父 updated</h6><h5 id="第四部分：销毁过程"><a href="#第四部分：销毁过程" class="headerlink" title="第四部分：销毁过程"></a>第四部分：销毁过程</h5><h6 id="父-beforeDestroy-gt-子-beforeDestroy-gt-子-destroyed-gt-父-destroyed"><a href="#父-beforeDestroy-gt-子-beforeDestroy-gt-子-destroyed-gt-父-destroyed" class="headerlink" title="父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed"></a>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</h6><hr>
<h2 id="8、在那个生命周期内调用异步请求？"><a href="#8、在那个生命周期内调用异步请求？" class="headerlink" title="8、在那个生命周期内调用异步请求？"></a>8、在那个生命周期内调用异步请求？</h2><h5 id="答：大部分时候，会在created发送请求。"><a href="#答：大部分时候，会在created发送请求。" class="headerlink" title="答：大部分时候，会在created发送请求。"></a>答：大部分时候，会在created发送请求。</h5><h6 id="1）、此时data已经挂载到Vue实例了，放在beforeCreate里太早，Vue实例没有数据，放在mounted里太晚"><a href="#1）、此时data已经挂载到Vue实例了，放在beforeCreate里太早，Vue实例没有数据，放在mounted里太晚" class="headerlink" title="1）、此时data已经挂载到Vue实例了，放在beforeCreate里太早，Vue实例没有数据，放在mounted里太晚"></a>1）、此时data已经挂载到Vue实例了，放在beforeCreate里太早，Vue实例没有数据，放在mounted里太晚</h6><h6 id="2）、放在-created-中有助于一致性，因为ssr不支持-beforeMount-、mounted-钩子函数。"><a href="#2）、放在-created-中有助于一致性，因为ssr不支持-beforeMount-、mounted-钩子函数。" class="headerlink" title="2）、放在 created 中有助于一致性，因为ssr不支持 beforeMount 、mounted 钩子函数。"></a>2）、放在 created 中有助于一致性，因为ssr不支持 beforeMount 、mounted 钩子函数。</h6><p>Created的使用场景：如果组件的初始数据来自于后端，那就在created里发送请求</p>
<hr>
<h2 id="9、组件中data为什么是一个函数？"><a href="#9、组件中data为什么是一个函数？" class="headerlink" title="9、组件中data为什么是一个函数？"></a>9、组件中data为什么是一个函数？</h2><h6 id="答：-data时引用类型，如果不是函数，所有组件的data会指向同一块内存区域，导致数据之间互相影响。而使用函数时，每次实例化组件值，调用函数，return一个新的（new）的data对象。这样每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性不会互相影响。"><a href="#答：-data时引用类型，如果不是函数，所有组件的data会指向同一块内存区域，导致数据之间互相影响。而使用函数时，每次实例化组件值，调用函数，return一个新的（new）的data对象。这样每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性不会互相影响。" class="headerlink" title="答： data时引用类型，如果不是函数，所有组件的data会指向同一块内存区域，导致数据之间互相影响。而使用函数时，每次实例化组件值，调用函数，return一个新的（new）的data对象。这样每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性不会互相影响。"></a>答： data时引用类型，如果不是函数，所有组件的data会指向同一块内存区域，导致数据之间互相影响。而使用函数时，每次实例化组件值，调用函数，return一个新的（new）的data对象。这样每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性不会互相影响。</h6><hr>
<h2 id="10、v-model的原理？"><a href="#10、v-model的原理？" class="headerlink" title="10、v-model的原理？"></a>10、v-model的原理？</h2><h6 id="v-model指令主要用在表单元素上实现数据双向绑定的。"><a href="#v-model指令主要用在表单元素上实现数据双向绑定的。" class="headerlink" title="v-model指令主要用在表单元素上实现数据双向绑定的。"></a>v-model指令主要用在表单元素上实现数据双向绑定的。</h6><h6 id="例如：input、textarea、select等创建双向数据绑定，本质上不过是语法糖，其实v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件："><a href="#例如：input、textarea、select等创建双向数据绑定，本质上不过是语法糖，其实v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：" class="headerlink" title="例如：input、textarea、select等创建双向数据绑定，本质上不过是语法糖，其实v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件："></a>例如：input、textarea、select等创建双向数据绑定，本质上不过是语法糖，其实v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</h6><ul>
<li>text和textarea元素使用 value 属性和 input 事件；</li>
<li>checkbox 和radio 使用 checked 属性和 change事件；</li>
<li>select 字段将value作为 prop 并将 change 作为事件。</li>
</ul>
<hr>
<h2 id="11、Vue实现数据绑定的原理？"><a href="#11、Vue实现数据绑定的原理？" class="headerlink" title="11、Vue实现数据绑定的原理？"></a>11、Vue实现数据绑定的原理？</h2><h4 id="Vue数据绑定是通过-数据劫持-和-观察者模式-的方式来实现的。"><a href="#Vue数据绑定是通过-数据劫持-和-观察者模式-的方式来实现的。" class="headerlink" title="Vue数据绑定是通过 数据劫持 和 观察者模式 的方式来实现的。"></a>Vue数据绑定是通过 <em>数据劫持</em> 和 <em>观察者模式</em> 的方式来实现的。</h4><h6 id="1、数据劫持：使用Object-defineProperty"><a href="#1、数据劫持：使用Object-defineProperty" class="headerlink" title="1、数据劫持：使用Object.defineProperty();"></a>1、数据劫持：使用Object.defineProperty();</h6><h6 id="目的是：感知属性的变化。当给属性赋值时，程序是能够感知的（知道的）。如果知道的话，就可以控制属性值的有效变化范围，也可以改变其他属性的值等。"><a href="#目的是：感知属性的变化。当给属性赋值时，程序是能够感知的（知道的）。如果知道的话，就可以控制属性值的有效变化范围，也可以改变其他属性的值等。" class="headerlink" title="目的是：感知属性的变化。当给属性赋值时，程序是能够感知的（知道的）。如果知道的话，就可以控制属性值的有效变化范围，也可以改变其他属性的值等。"></a>目的是：<em>感知属性的变化</em>。当给属性赋值时，程序是能够感知的（知道的）。如果知道的话，就可以控制属性值的有效变化范围，也可以改变其他属性的值等。</h6><p>  当你把一个普通的 JavaScript 对象（json）传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。</p>
<h6 id="2、观察者模式（发布订阅者模式）："><a href="#2、观察者模式（发布订阅者模式）：" class="headerlink" title="2、观察者模式（发布订阅者模式）："></a>2、观察者模式（发布订阅者模式）：</h6><h6 id="目的：当属性发生变化时，使用该数据地方（模板，计算属性，wath等等）跟着变化"><a href="#目的：当属性发生变化时，使用该数据地方（模板，计算属性，wath等等）跟着变化" class="headerlink" title="目的：当属性发生变化时，使用该数据地方（模板，计算属性，wath等等）跟着变化"></a>目的：当属性发生变化时，使用该数据地方（模板，计算属性，wath等等）跟着变化</h6><hr>
<h2 id="Object-defineProperty-函数详解"><a href="#Object-defineProperty-函数详解" class="headerlink" title="Object.defineProperty()函数详解"></a>Object.defineProperty()函数详解</h2><p>ES5新增的函数Object.defineProperty()，可以给<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=JavaScript&amp;spm=1001.2101.3001.7020">JavaScript</a>对象增加属性。啊……，那以前的json对象不是本来就可以吗。为何还得搞出个这么复杂的函数来做这个事情。</p>
<h3 id="一、代码部分"><a href="#一、代码部分" class="headerlink" title="一、代码部分"></a>一、代码部分</h3><h4 id="1、回顾一下json对象增加属性"><a href="#1、回顾一下json对象增加属性" class="headerlink" title="1、回顾一下json对象增加属性"></a>1、回顾一下json对象增加属性</h4><pre class="line-numbers language-none"><code class="language-none">//定义一个对象

Var person = {};

//给对象增加一个属性

Person.age = 12;

Person.name = “张三疯”;

Person.isAdult =”未成年”;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Ok，没有问题。但是：</p>
<p>1)、思考一个问题，age属性的值应该是有个用有效范围的（如：0-150），但是，这样增加的属性没法限制age属性的取值范围</p>
<p>2）、如果age属性的变化，会引起其它属性的变化，即其它属性的值会随着age的变化而变化，这样没法很好控制，而且很容易控制不好。如以上属性isAdult的值，不能直接随便赋值，而是age的值变化后，isAdult 的值会跟着变化。</p>
<h4 id="2、如果用Object-defineProperty-函数给对象增加属性"><a href="#2、如果用Object-defineProperty-函数给对象增加属性" class="headerlink" title="2、如果用Object.defineProperty()函数给对象增加属性"></a>2、如果用Object.defineProperty()函数给对象增加属性</h4><pre class="line-numbers language-none"><code class="language-none">Var person = {};

Object.defineProperty(person ,"name",{

    value:"张三疯",

    writable:false//属性name不能修改

});

Console.log(person.name);//张三疯

person.name = "隔壁老王"; //修改不成功

console.log(person.name);//张三疯<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>没想到吧，我们还可以让某些属性的值是只读的。</p>
<h4 id="3、如果用-Object-defineProperty-进行给对象增加属性，该属性的取值是可控的，而且会影响其它属性的变化。"><a href="#3、如果用-Object-defineProperty-进行给对象增加属性，该属性的取值是可控的，而且会影响其它属性的变化。" class="headerlink" title="3、如果用 Object.defineProperty()进行给对象增加属性，该属性的取值是可控的，而且会影响其它属性的变化。"></a>3、如果用 Object.defineProperty()进行给对象增加属性，该属性的取值是可控的，而且会影响其它属性的变化。</h4><p>注意：以下代码中，在对象的定义中，写的是带下划线的：_age，而在defineProperty()函数里写的属性名是不带下划线的:age，外部使用该对象的属性时，用不带下划线的：</p>
<pre class="line-numbers language-none"><code class="language-none"> 
let person = {
    _age:12,
    isAdult:"未成年"
};
Object.defineProperty(person,"age",{
    get:function(){
        return this._age;
    },
    set:function(newValue){
        //此判断是限制属性的取值范围是0-150之间
        if(newValue&lt;0 || newValue&gt;150){
            return;
        }
        this._age = newValue;
        //此判断是 _age属性的值影响isAdult的值。
        if(this._age&gt;=18){
            this.isAdult = "已成年";
        }else{
            this.isAdult = "未成年";
        }
    }
});
 
person.age = 16; //此句话会调用 set函数。
console.log(person.age);//此句话对调动get函数
console.log(person.isAdult);//未成年
 
person.age = 25; //此句话会调用 set函数。
console.log(person.age);//此句话对调动get函数
console.log(person.isAdult);//已成年<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="二、概念："><a href="#二、概念：" class="headerlink" title="二、概念："></a>二、概念：</h3><h4 id="1、普及一个概念，JavaScript的属性有三种类型（重点看前两点）："><a href="#1、普及一个概念，JavaScript的属性有三种类型（重点看前两点）：" class="headerlink" title="1、普及一个概念，JavaScript的属性有三种类型（重点看前两点）："></a>1、普及一个概念，JavaScript的属性有三种类型（重点看前两点）：</h4><h6 id="1-、命名数据属性：拥有一个确定的值的属性。这也是最常见的属性。"><a href="#1-、命名数据属性：拥有一个确定的值的属性。这也是最常见的属性。" class="headerlink" title="1)、命名数据属性：拥有一个确定的值的属性。这也是最常见的属性。"></a>1)、命名数据属性：拥有一个确定的值的属性。这也是最常见的属性。</h6><h6 id="2）、命名访问器属性：通过getter和setter进行读取和赋值的属性（重点描述）"><a href="#2）、命名访问器属性：通过getter和setter进行读取和赋值的属性（重点描述）" class="headerlink" title="2）、命名访问器属性：通过getter和setter进行读取和赋值的属性（重点描述）"></a>2）、命名访问器属性：通过getter和setter进行读取和赋值的属性（重点描述）</h6><h6 id="3）、内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性-Prototype-，你不能直接访问这个属性，但可以通过Object-getPrototypeOf-方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性"><a href="#3）、内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性-Prototype-，你不能直接访问这个属性，但可以通过Object-getPrototypeOf-方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性" class="headerlink" title="3）、内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性[[Prototype]]，你不能直接访问这个属性，但可以通过Object.getPrototypeOf()方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性"></a>3）、内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性[[Prototype]]，你不能直接访问这个属性，但可以通过Object.getPrototypeOf()方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性</h6><h4 id="2、Object-defineProperty-的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。"><a href="#2、Object-defineProperty-的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。" class="headerlink" title="2、Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。"></a>2、<strong>Object.defineProperty()的作用</strong>就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。</h4><h4 id="3、、Object-defineProperty-函数的格式："><a href="#3、、Object-defineProperty-函数的格式：" class="headerlink" title="3、、Object.defineProperty()函数的格式："></a>3、<strong>、Object.defineProperty()函数的格式：</strong></h4><h6 id="Object-defineProperty-obj-prop-desc"><a href="#Object-defineProperty-obj-prop-desc" class="headerlink" title="Object.defineProperty(obj, prop, desc)"></a>Object.defineProperty(obj, prop, desc)</h6><h6 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h6><h6 id="Obj：表示增加属性的对象"><a href="#Obj：表示增加属性的对象" class="headerlink" title="Obj：表示增加属性的对象"></a>Obj：表示增加属性的对象</h6><h6 id="Prop：属性名"><a href="#Prop：属性名" class="headerlink" title="Prop：属性名"></a>Prop：属性名</h6><h6 id="Desc：属性描述符"><a href="#Desc：属性描述符" class="headerlink" title="Desc：属性描述符"></a>Desc：属性描述符</h6><h4 id="4、属性描述符"><a href="#4、属性描述符" class="headerlink" title="4、属性描述符"></a>4、属性描述符</h4><p>1)、概念：</p>
<p> 属性描述符，是对当前属性的描述（包括设置）。</p>
<p>如 以上代码：</p>
<pre><code>Object.defineProperty(person ,"name",{
value:"张三疯"
});
</code></pre>
<p>中的value就表示name属性的值为 “张三疯”。</p>
<p>2)、属性描述分为：数据描述符和存取描述符，</p>
<p>​    （1）、数据描述符有两个：value和writable</p>
<p>​    （2）、存取描述符：是由一对 getter、setter 函数功能来描述的属性</p>
<p>3)、共有的描述符：</p>
<p>数据描述符和存取描述均具有以下描述符</p>
<p>Configrable，enumerable</p>
<p>4)、属性描述符的解释</p>
<p>Value: 属性的取值</p>
<p>Writable:属性是否可以修改</p>
<p>configurable描述属性是否配置，以及可否删除</p>
<p>enumerable 描述属性是否会出现在for in 或者 Object.keys()的遍历中</p>
<p>get：针对命名访问器属性值的获取</p>
<p>Set：针对命名访问器属性值的修改</p>
<p>默认值：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>Value</td>
<td>Undefined</td>
</tr>
<tr>
<td>Writable</td>
<td>False</td>
</tr>
<tr>
<td>configurable</td>
<td>False</td>
</tr>
<tr>
<td>enumerable</td>
<td>False</td>
</tr>
<tr>
<td>get</td>
<td>Undefined</td>
</tr>
<tr>
<td>Set</td>
<td>Undefined</td>
</tr>
</tbody></table>
<hr>
<h2 id="12、Vue组件通信有哪几种方式？"><a href="#12、Vue组件通信有哪几种方式？" class="headerlink" title="12、Vue组件通信有哪几种方式？"></a>12、Vue组件通信有哪几种方式？</h2><p> Vue 组件间通信主要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式：</p>
<h6 id="1）、props-x2F-emit：父子组件通信"><a href="#1）、props-x2F-emit：父子组件通信" class="headerlink" title="1）、props/$emit：父子组件通信"></a>1）、props/$emit：父子组件通信</h6><h6 id="2）、ref：适用父子组件通信"><a href="#2）、ref：适用父子组件通信" class="headerlink" title="2）、ref：适用父子组件通信"></a>2）、ref：适用父子组件通信</h6><h6 id="3）、EventBus-（-emit-x2F-on）：-适用于-父子、隔代、兄弟组件通信"><a href="#3）、EventBus-（-emit-x2F-on）：-适用于-父子、隔代、兄弟组件通信" class="headerlink" title="3）、EventBus （$emit / $on）： 适用于 父子、隔代、兄弟组件通信"></a>3）、EventBus （$emit / $on）： 适用于 父子、隔代、兄弟组件通信</h6><h6 id="4）、-root：集中管理，适用于所有场景"><a href="#4）、-root：集中管理，适用于所有场景" class="headerlink" title="4）、$root：集中管理，适用于所有场景**"></a>4）、$root：集中管理，适用于所有场景**</h6><h6 id="5）、Vuex-适用于所有场景"><a href="#5）、Vuex-适用于所有场景" class="headerlink" title="5）、Vuex 适用于所有场景**"></a>5）、Vuex 适用于所有场景**</h6><hr>
<h2 id="13、谈谈你对-keep-alive-的了解？"><a href="#13、谈谈你对-keep-alive-的了解？" class="headerlink" title="13、谈谈你对 keep-alive 的了解？"></a>13、谈谈你对 keep-alive 的了解？</h2><p>keep-alive 可以缓存组件及其的组件的状态（数据），避免了组件的频繁创建和销毁所带来的性能损耗。</p>
<p>它有三个特性：</p>
<h6 id="1）、用于缓存组件，一般结合路由和动态组件一起使用。"><a href="#1）、用于缓存组件，一般结合路由和动态组件一起使用。" class="headerlink" title="1）、用于缓存组件，一般结合路由和动态组件一起使用。"></a>1）、用于缓存组件，一般结合路由和动态组件一起使用。</h6><h6 id="2）、提供-include-和-exclude-属性。两者都支持字符串或正则表达式，-include-表示只有名称匹配的组件会被缓存，exclude-表示任何名称匹配的组件都不会被缓存-，其中-exclude-的优先级比-include-高；"><a href="#2）、提供-include-和-exclude-属性。两者都支持字符串或正则表达式，-include-表示只有名称匹配的组件会被缓存，exclude-表示任何名称匹配的组件都不会被缓存-，其中-exclude-的优先级比-include-高；" class="headerlink" title="2）、提供 include 和 exclude 属性。两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；"></a>2）、提供 include 和 exclude 属性。两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</h6><h6 id="3）、对应两个钩子函数-activated-和-deactivated-，当组件被激活时，触发钩子函数-activated，当组件被移除时，触发钩子函数-deactivated。"><a href="#3）、对应两个钩子函数-activated-和-deactivated-，当组件被激活时，触发钩子函数-activated，当组件被移除时，触发钩子函数-deactivated。" class="headerlink" title="3）、对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。"></a>3）、对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</h6><hr>
<h2 id="14、Vue-中的-key-有什么作用？"><a href="#14、Vue-中的-key-有什么作用？" class="headerlink" title="14、Vue 中的 key 有什么作用？"></a>14、Vue 中的 key 有什么作用？</h2><p><strong>首先</strong></p>
<p> key 是Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</p>
<p><strong>再说一下</strong>，diff算法的执行过程：</p>
<p>1）、oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，<br>2）、在新节点和旧节点进行两两对比时，共有4种比较方式：<br>a.newStartIndex 和oldStartIndex 、<br>b.newEndIndex 和 oldEndIndex 、<br>c.newStartIndex 和 oldEndIndex 、<br>d.newEndIndex 和 oldStartIndex，<br>如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较。</p>
<hr>
<h2 id="15、你对Vue项目进行哪些优化？"><a href="#15、你对Vue项目进行哪些优化？" class="headerlink" title="15、你对Vue项目进行哪些优化？"></a>15、你对Vue项目进行哪些优化？</h2><h5 id="第一个方面：代码层面的优化"><a href="#第一个方面：代码层面的优化" class="headerlink" title="第一个方面：代码层面的优化"></a>第一个方面：代码层面的优化</h5><h6 id="v-if-和-v-show-区分使用场景"><a href="#v-if-和-v-show-区分使用场景" class="headerlink" title="v-if 和 v-show 区分使用场景"></a>v-if 和 v-show 区分使用场景</h6><h6 id="computed-和-watch-区分使用场景"><a href="#computed-和-watch-区分使用场景" class="headerlink" title="computed 和 watch 区分使用场景"></a>computed 和 watch 区分使用场景</h6><h6 id="v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h6><h6 id="长列表性能优化"><a href="#长列表性能优化" class="headerlink" title="长列表性能优化"></a>长列表性能优化</h6><h6 id="事件的销毁"><a href="#事件的销毁" class="headerlink" title="事件的销毁"></a>事件的销毁</h6><h6 id="图片资源懒加载"><a href="#图片资源懒加载" class="headerlink" title="图片资源懒加载"></a>图片资源懒加载</h6><h6 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h6><h6 id="第三方插件的按需引入"><a href="#第三方插件的按需引入" class="headerlink" title="第三方插件的按需引入"></a>第三方插件的按需引入</h6><h6 id="优化无限列表性能"><a href="#优化无限列表性能" class="headerlink" title="优化无限列表性能"></a>优化无限列表性能</h6><h6 id="服务端渲染-SSR-or-预渲染"><a href="#服务端渲染-SSR-or-预渲染" class="headerlink" title="服务端渲染 SSR or 预渲染"></a>服务端渲染 SSR or 预渲染</h6><h5 id="第二个方面：Webpack-层面的优化"><a href="#第二个方面：Webpack-层面的优化" class="headerlink" title="第二个方面：Webpack 层面的优化"></a>第二个方面：Webpack 层面的优化</h5><h6 id="Webpack-对图片进行压缩"><a href="#Webpack-对图片进行压缩" class="headerlink" title="Webpack 对图片进行压缩"></a>Webpack 对图片进行压缩</h6><h6 id="减少-ES6-转为-ES5-的冗余代码"><a href="#减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="减少 ES6 转为 ES5 的冗余代码"></a>减少 ES6 转为 ES5 的冗余代码</h6><h6 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h6><h6 id="模板预编译"><a href="#模板预编译" class="headerlink" title="模板预编译"></a>模板预编译</h6><h6 id="提取组件的-CSS"><a href="#提取组件的-CSS" class="headerlink" title="提取组件的 CSS"></a>提取组件的 CSS</h6><h6 id="优化-SourceMap"><a href="#优化-SourceMap" class="headerlink" title="优化 SourceMap"></a>优化 SourceMap</h6><h6 id="构建结果输出分析"><a href="#构建结果输出分析" class="headerlink" title="构建结果输出分析"></a>构建结果输出分析</h6><h6 id="Vue-项目的编译优化"><a href="#Vue-项目的编译优化" class="headerlink" title="Vue 项目的编译优化"></a>Vue 项目的编译优化</h6><h5 id="第三个方面：基础的-Web-技术的优化"><a href="#第三个方面：基础的-Web-技术的优化" class="headerlink" title="第三个方面：基础的 Web 技术的优化"></a>第三个方面：基础的 Web 技术的优化</h5><h6 id="开启-gzip-压缩"><a href="#开启-gzip-压缩" class="headerlink" title="开启 gzip 压缩"></a>开启 gzip 压缩</h6><h6 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h6><h6 id="CDN-的使用"><a href="#CDN-的使用" class="headerlink" title="CDN 的使用"></a>CDN 的使用</h6><h6 id="使用-Chrome-Performance-查找性能瓶颈"><a href="#使用-Chrome-Performance-查找性能瓶颈" class="headerlink" title="使用 Chrome Performance 查找性能瓶颈"></a>使用 Chrome Performance 查找性能瓶颈</h6><hr>
<h2 id="16、动态路由传参2种方式params与query"><a href="#16、动态路由传参2种方式params与query" class="headerlink" title="16、动态路由传参2种方式params与query"></a>16、动态路由传参2种方式params与query</h2><h4 id="一、格式的区别"><a href="#一、格式的区别" class="headerlink" title="一、格式的区别"></a>一、格式的区别</h4><h5 id="1）、params"><a href="#1）、params" class="headerlink" title="1）、params"></a>1）、params</h5><p>传</p>
<pre class="line-numbers language-none"><code class="language-none">//声明式：
&lt;router-link :to="{name:'user',params:{id:123}}"&gt;User&lt;/router-link&gt;

//编程式：
$router.push({name:'user',params:{id:'123'}})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接</p>
<pre class="line-numbers language-none"><code class="language-none">//模板里的写法：
$route.params.参数名

//脚本里的写法：
this.$route.params.参数名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>动态路由匹配也行。</p>
<pre class="line-numbers language-none"><code class="language-none">1）、路由配置：{ path: '/user/:id', component: User }
2）、传参：

//声明式 &lt;router-link to="/user/01001"&gt;用户01001的信息&lt;/router-link&gt; //编程式 $router.push("/user/01001");

3）、接值：

//模板里的写法： $route.params.参数名

//脚本里的写法: this.$route.params.参数名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2）、query"><a href="#2）、query" class="headerlink" title="2）、query"></a>2）、query</h5><p>传：</p>
<pre class="line-numbers language-none"><code class="language-none">// 带查询参数，变成 /register?plan=private
$router.push({ path: '/register', query: { plan: 'private' }})
注意：如果提供了 path，那么params 会被忽略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>接：</p>
<pre class="line-numbers language-none"><code class="language-none">//模板里的写法：
$route.query.参数名 
//脚本里的写法:
this.$route.query.参数名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="二、使用场景的区别："><a href="#二、使用场景的区别：" class="headerlink" title="二、使用场景的区别："></a>二、使用场景的区别：</h4><p>1、params：在传递一个参数时使用，如果参数多的话，地址上不利于阅读</p>
<p>2、query：在传递多个参数时使用，地址比params好阅读</p>
<hr>
<h2 id="17、Vue实例和Vue组件写法的区别？"><a href="#17、Vue实例和Vue组件写法的区别？" class="headerlink" title="17、Vue实例和Vue组件写法的区别？"></a>17、Vue实例和Vue组件写法的区别？</h2><h6 id="1、data是个函数-一个组件的data选项必须是一个函数，且要有返回Object，只有这样，每个实例（Vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据互相影响，也就是说，组件的作用域是独立的。"><a href="#1、data是个函数-一个组件的data选项必须是一个函数，且要有返回Object，只有这样，每个实例（Vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据互相影响，也就是说，组件的作用域是独立的。" class="headerlink" title="1、data是个函数 一个组件的data选项必须是一个函数，且要有返回Object，只有这样，每个实例（Vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据互相影响，也就是说，组件的作用域是独立的。"></a>1、data是个函数 一个组件的data选项必须是一个函数，且要有返回Object，只有这样，每个实例（Vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据互相影响，也就是说，组件的作用域是独立的。</h6><h6 id="2、组件模板（html）只能有一个根标签"><a href="#2、组件模板（html）只能有一个根标签" class="headerlink" title="2、组件模板（html）只能有一个根标签"></a>2、组件模板（html）只能有一个根标签</h6><h6 id="3、组件名不可和HTML官方的标签名同名"><a href="#3、组件名不可和HTML官方的标签名同名" class="headerlink" title="3、组件名不可和HTML官方的标签名同名"></a>3、组件名不可和HTML官方的标签名同名</h6><h6 id="4、组件没有el选项，只有根实例存在el"><a href="#4、组件没有el选项，只有根实例存在el" class="headerlink" title="4、组件没有el选项，只有根实例存在el"></a>4、组件没有el选项，只有根实例存在el</h6><h6 id="5、书写：组件名如果驼峰，那么使用时，用短横线链接"><a href="#5、书写：组件名如果驼峰，那么使用时，用短横线链接" class="headerlink" title="5、书写：组件名如果驼峰，那么使用时，用短横线链接"></a>5、书写：组件名如果驼峰，那么使用时，用短横线链接</h6><hr>
<h2 id="18、谈谈你对VueX的理解？"><a href="#18、谈谈你对VueX的理解？" class="headerlink" title="18、谈谈你对VueX的理解？"></a>18、谈谈你对VueX的理解？</h2><h4 id="1、VueX是干什么的"><a href="#1、VueX是干什么的" class="headerlink" title="1、VueX是干什么的"></a>1、VueX是干什么的</h4><h6 id="Vuex能够保存全局数据，供整个应用使用，可以在组件之间传递数据。"><a href="#Vuex能够保存全局数据，供整个应用使用，可以在组件之间传递数据。" class="headerlink" title="Vuex能够保存全局数据，供整个应用使用，可以在组件之间传递数据。"></a>Vuex能够<em>保存全局数据</em>，供整个应用使用，可以在组件之间传递数据。</h6><h6 id="Vuex保存的数据是响应式的"><a href="#Vuex保存的数据是响应式的" class="headerlink" title="Vuex保存的数据是响应式的"></a>Vuex保存的数据是<em>响应式的</em></h6><h6 id="Vuex保存的数据可以跟踪状态的变化"><a href="#Vuex保存的数据可以跟踪状态的变化" class="headerlink" title="Vuex保存的数据可以跟踪状态的变化"></a>Vuex保存的数据可以<em>跟踪状态的变化</em></h6><h4 id="2、VueX的核心概念"><a href="#2、VueX的核心概念" class="headerlink" title="2、VueX的核心概念"></a>2、VueX的核心概念</h4><h6 id="state：数据仓库，存储所有的共享数据，相当于Vue组件里的-data"><a href="#state：数据仓库，存储所有的共享数据，相当于Vue组件里的-data" class="headerlink" title="state：数据仓库，存储所有的共享数据，相当于Vue组件里的 data"></a>state：数据仓库，存储所有的共享数据，相当于Vue组件里的 data</h6><h6 id="getter：在state的基础上派生的数据，相当于Vue组件里的-computed"><a href="#getter：在state的基础上派生的数据，相当于Vue组件里的-computed" class="headerlink" title="getter：在state的基础上派生的数据，相当于Vue组件里的 computed"></a>getter：在state的基础上派生的数据，相当于Vue组件里的 computed</h6><h6 id="mutation：修改state的数据时，用mutation，这与跟踪状态有关系"><a href="#mutation：修改state的数据时，用mutation，这与跟踪状态有关系" class="headerlink" title="mutation：修改state的数据时，用mutation，这与跟踪状态有关系"></a>mutation：修改state的数据时，用mutation，这与跟踪状态有关系</h6><h6 id="action：解决mutation里只能由同步代码的问题，action里可以有异步代码"><a href="#action：解决mutation里只能由同步代码的问题，action里可以有异步代码" class="headerlink" title="action：解决mutation里只能由同步代码的问题，action里可以有异步代码"></a>action：解决mutation里只能由同步代码的问题，action里可以有异步代码</h6><h4 id="3、VueX的数据流"><a href="#3、VueX的数据流" class="headerlink" title="3、VueX的数据流"></a>3、VueX的数据流</h4><p>组件里的dispath（派发）VueX中的action里commit（提交）mutation，mutation里修改state。state被修改后，会响应式到组件上。</p>
<h4 id="4、辅助函数"><a href="#4、辅助函数" class="headerlink" title="4、辅助函数"></a>4、辅助函数</h4><p>现在的面试，都会问的比较多。而且在项目中大部分都会使用辅助函数来简化项目中的代码。</p>
<p>有了这些辅助函数后，在组件里，不用再写$store了</p>
<h6 id="mapState：把VueX中的state（状态）映射（合并）到组件对象的computed上。直接使用计算属性就可以拿到VueX的状态"><a href="#mapState：把VueX中的state（状态）映射（合并）到组件对象的computed上。直接使用计算属性就可以拿到VueX的状态" class="headerlink" title="mapState：把VueX中的state（状态）映射（合并）到组件对象的computed上。直接使用计算属性就可以拿到VueX的状态"></a>mapState：把VueX中的state（状态）映射（合并）到组件对象的computed上。直接使用计算属性就可以拿到VueX的状态</h6><h6 id="mapGetters：把VueX的getters映射到组件computed上。"><a href="#mapGetters：把VueX的getters映射到组件computed上。" class="headerlink" title="mapGetters：把VueX的getters映射到组件computed上。"></a>mapGetters：把VueX的getters映射到组件computed上。</h6><h6 id="mapMutations：把VueX的mutations映射到组件的methods上"><a href="#mapMutations：把VueX的mutations映射到组件的methods上" class="headerlink" title="mapMutations：把VueX的mutations映射到组件的methods上"></a>mapMutations：把VueX的mutations映射到组件的methods上</h6><h6 id="mapActions：把VueX的actions映射到组件的methods上。"><a href="#mapActions：把VueX的actions映射到组件的methods上。" class="headerlink" title="mapActions：把VueX的actions映射到组件的methods上。"></a>mapActions：把VueX的actions映射到组件的methods上。</h6><p>示例代码：</p>
<pre class="line-numbers language-none"><code class="language-none">//1、vueX
export default new vueX.Store({
   state:{
       count:10
   }
})
 
//2、组件里
import { mapState } from "vuex";
 
export default {
  name: "Store01",
  data() {
    return {};
  },
  computed:{        
        ...mapState(['count']), //把vuex的state映射到组件的计算属性上
        a:function(){
            return 250;
        },
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5、modules"><a href="#5、modules" class="headerlink" title="5、modules"></a>5、modules</h4><p>当项目比较大时，所有的全局数据存放在state里，会非常混乱，怎么办？使用module，把数据分门别类的进行处理，即：<strong>模块化</strong>。 每个模块是一个独立的store。然后由总体的store引入所有的分模块store。</p>
<p>示例代码：</p>
<pre class="line-numbers language-none"><code class="language-none">//1、moduleA.js  此模块里管理的数据是 count。
 
export default {
    namespaced:true, //这个命名空间是区分不同模块的
    state:{
        count:1
    },
    mutations:{
       ……………………
    },
    actions:{        
        incCount(context){
            console.log("moduleA的action");
            setTimeout(()=&gt;{
                context.commit("incCount");
            },2000);
        }
    }
}
 
2、创建vueX.store对象
 
 
import moduleA from "./moduleA";
 
export default new vueX.Store({
    modules:{
        moduleA:moduleA
    }
    //简写：
    modules:{
        moduleA,moduleB
    }
});
 
 
//2、组件里派发action时，加上namespaced，用来区分不同的模块
 
this.$store.dispatch('moduleA/incCount');//moduleA就是模块名。保证派发的是moduleA里的incCount。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="19、Vue路由懒加载"><a href="#19、Vue路由懒加载" class="headerlink" title="19、Vue路由懒加载"></a>19、Vue路由懒加载</h2><p>vue的SPA（Single Page Application）应用里，当（webpack）打包构建时，会把所有的js打在一起，JavaScript 包会变得非常大，并在第一次请求时全部下载完毕，影响页面加载（性能）。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>目前有三种方式实现路由组件的懒加载，分别是：</p>
<ul>
<li><p>Vue的异步组件</p>
</li>
<li><p>es的import()</p>
</li>
<li><p>webpack的require.ensure()</p>
<h4 id="1-、Vue异步组件"><a href="#1-、Vue异步组件" class="headerlink" title="1)、Vue异步组件"></a>1)、Vue异步组件</h4><p>把路由配置，进行修改</p>
<pre class="line-numbers language-none"><code class="language-none">{
	path: '/shopcar',
	name: 'shopcar',
	compontent: resoleve =&gt; require(['@/pages/ShopCar'],resoleve)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>1）、运行时打开chrome的network，就会看到进入路由 /shopcar 时，会多出另外 一个js文件。一般是0.js或者1.js</p>
<p>2）、用npm run build打包时，wepback就会多打了一个 js文件（如：0.b5a82d6947b2e30edcc8.js），这个js文件就是把ShopCar文件进行了单独打包。同样的在network里，就会看到进入路由 /shopcar 时，多出一个单独的js文件的请求</p>
</li>
</ul>
<p>注：这种方式，webpack会把每个异步组件单独打成一个js文件。</p>
<h4 id="2）、es的import"><a href="#2）、es的import" class="headerlink" title="2）、es的import()"></a>2）、es的import()</h4><p>主要是把原来的引入方式进行修改 ，路由配置就不用改了：</p>
<h5 id="1、不指定webpackChunkName，每个组件单独打一个js文件"><a href="#1、不指定webpackChunkName，每个组件单独打一个js文件" class="headerlink" title="1、不指定webpackChunkName，每个组件单独打一个js文件"></a>1、不指定webpackChunkName，每个组件单独打一个js文件</h5><p>原来是：import ShopCar from ‘@/pages/ShopCar’</p>
<p>修改后：const ShopCar = () =&gt; import(‘@/pages/ShopCar’);</p>
<p>修改后的做法是定义了一个函数，由于函数不调用不执行，所有，一开始时，并不会引入该组件，只有路由跳转时才会调用该函数。</p>
<h5 id="2、指定webpackChunkName，相同的webpackChunkName就会打在同一个js文件里"><a href="#2、指定webpackChunkName，相同的webpackChunkName就会打在同一个js文件里" class="headerlink" title="2、指定webpackChunkName，相同的webpackChunkName就会打在同一个js文件里"></a>2、指定webpackChunkName，相同的webpackChunkName就会打在同一个js文件里</h5><p>1）、以下两个组件的webpackChunkName相同，所以，打在一个js文件里</p>
<pre class="line-numbers language-none"><code class="language-none">const ShopCar = () =&gt; import(/* webpackChunkName: 'demot' */ '@/pages/ShopCar');

const GoodsDetailPage = () =&gt; import(/* webpackChunkName: 'demot' */ '@/pages/GoodsDetailPage');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>2）、下面这个组件的webpackChunkName和上面两个不一样，所以，单独打在一个js文件里</p>
<pre class="line-numbers language-none"><code class="language-none">const Login = () =&gt; import(/* webpackChunkName: 'demoty' */ '@/pages/Login');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h4 id="3）、webpack的require-ensure"><a href="#3）、webpack的require-ensure" class="headerlink" title="3）、webpack的require.ensure()"></a>3）、webpack的require.ensure()</h4><p>这种方式，只改路由配置即可。</p>
<p>如：</p>
<pre class="line-numbers language-none"><code class="language-none">{

    path: '/GoodsDetailPage',

    name: 'GoodsDetailPage',

    component: r =&gt; require.ensure([], () =&gt; r(require('@/pages/GoodsDetailPage')), 'demot')

},

{

    path: '/Login',

    name: 'Login',

    component: r =&gt; require.ensure([], () =&gt; r(require('@/pages/Login')), 'demot')

},

{

    path: '/shopcar',

    name: 'shopcar',
    
    component: r =&gt; require.ensure([], () =&gt; r(require('@/pages/ShopCar')), 'demoty')

},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以上代码中，我把Login和GoodsDetailPage使用了相同的chunkName</p>
<hr>
<h2 id="20、MV-（MVC-MVP-MVVM）"><a href="#20、MV-（MVC-MVP-MVVM）" class="headerlink" title="20、MV*（MVC,MVP,MVVM）"></a>20、MV*（MVC,MVP,MVVM）</h2><p>首先MVC，MVP，MVVM都是为了解决UI页面与逻辑代码分离而出现的模式，MVP和MVVM都是MVC的基础上演化而来。他不属于某种语言的框架，只要是有UI页面与逻辑代码我们都可以使用这几种框架去搭建我们的项目。他是一种框架模式。<br>        M和V分别指Model层和View层，但其功能会因为框架的不同而变化。Model层是数据模型，用来存储数据；View层是视图，展示Model层的数据。<br>        虽然在不同的MV(XX)框架中，Model层和View层的内容可能会有所差别，但是其基础功能不变，变的只是 数据的传输方式 。</p>
<h3 id="预热："><a href="#预热：" class="headerlink" title="预热："></a>预热：</h3><h6 id="MVC-—–-Model-View-Controller：作为-Controller-层的-Actvity-x2F-Fragment-等充当了-View-的角色，代码过于臃肿；同时在-View-层又容易直接操作-Model，导致-View-和-Model-层耦合，无法独立复用。有时候看到一个-Activity-能有几千甚至上万行的代码，简直噩梦。"><a href="#MVC-—–-Model-View-Controller：作为-Controller-层的-Actvity-x2F-Fragment-等充当了-View-的角色，代码过于臃肿；同时在-View-层又容易直接操作-Model，导致-View-和-Model-层耦合，无法独立复用。有时候看到一个-Activity-能有几千甚至上万行的代码，简直噩梦。" class="headerlink" title="MVC  —–  Model-View-Controller：作为 Controller 层的 Actvity/Fragment 等充当了 View 的角色，代码过于臃肿；同时在 View 层又容易直接操作 Model，导致 View 和 Model 层耦合，无法独立复用。有时候看到一个 Activity 能有几千甚至上万行的代码，简直噩梦。"></a>MVC  —–  Model-View-Controller：作为 Controller 层的 Actvity/Fragment 等充当了 View 的角色，代码过于臃肿；同时在 View 层又容易直接操作 Model，导致 View 和 Model 层耦合，无法独立复用。有时候看到一个 Activity 能有几千甚至上万行的代码，简直噩梦。</h6><h6 id="MVP-——-Model-View-Presenter-Presenter-和-View-层之间通过定义接口实现通信，解耦了-View-和-Model-层。然而当业务场景比较复杂时，接口定义会越来越多，且可能定义模糊，接口一旦变化，对应实现也需要发生变化。"><a href="#MVP-——-Model-View-Presenter-Presenter-和-View-层之间通过定义接口实现通信，解耦了-View-和-Model-层。然而当业务场景比较复杂时，接口定义会越来越多，且可能定义模糊，接口一旦变化，对应实现也需要发生变化。" class="headerlink" title="MVP —— Model-View-Presenter: Presenter 和 View 层之间通过定义接口实现通信，解耦了 View 和 Model 层。然而当业务场景比较复杂时，接口定义会越来越多，且可能定义模糊，接口一旦变化，对应实现也需要发生变化。"></a>MVP —— Model-View-Presenter: Presenter 和 View 层之间通过定义接口实现通信，解耦了 View 和 Model 层。然而当业务场景比较复杂时，接口定义会越来越多，且可能定义模糊，接口一旦变化，对应实现也需要发生变化。</h6><h6 id="MVVM-——-Model-View-ViewModel-MVVM-解决了-MVP-的问题，使得-ViewModel-和-View-之间不再依赖接口通信，而是通过-LiveData-RxJava-Flow-等响应式开发的方式来通信。"><a href="#MVVM-——-Model-View-ViewModel-MVVM-解决了-MVP-的问题，使得-ViewModel-和-View-之间不再依赖接口通信，而是通过-LiveData-RxJava-Flow-等响应式开发的方式来通信。" class="headerlink" title="MVVM —— Model-View-ViewModel: MVVM 解决了 MVP 的问题，使得 ViewModel 和 View 之间不再依赖接口通信，而是通过 LiveData, RxJava, Flow 等响应式开发的方式来通信。"></a>MVVM —— Model-View-ViewModel: MVVM 解决了 MVP 的问题，使得 ViewModel 和 View 之间不再依赖接口通信，而是通过 LiveData, RxJava, Flow 等响应式开发的方式来通信。</h6><h5 id="MVC："><a href="#MVC：" class="headerlink" title="MVC："></a>MVC：</h5><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写<br>        Model：模型层，数据模型及其业务逻辑，是针对业务模型建立的数据结构，Model与View无关，而与业务有关。<br>        View：视图层，用于与用户实现交互的页面，通常实现数据的输入和输出功能。<br>        Controller：控制器，用于连接Model层和View层，完成Model层和View层的交互。还可以处理页面业务逻辑，它接收并处理来自用户的请求，并将Model返回给用户。</p>
<p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/1ecd7cdd734e43e7a8eb9a46edf18b36.png"></p>
<h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><p>耦合性低，生命周期成本低，部署快，可维护性高，适用于快速开发的小型项目</p>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>不适合大型，中等项目，View层Controller层连接过于紧密；View层对Model层的访问效率低；一般的高级UI页面工具和构造器不支持MVC模式</p>
<h5 id="MVP："><a href="#MVP：" class="headerlink" title="MVP："></a>MVP：</h5><p> MVP全名是Model View Presenter，是模型(model)－视图(view)－表示器(Presenter)的缩写<br>        Model：模型层，用于数据存储以及业务逻辑。<br>        View：视图层，用于展示与用户实现交互的页面，通常实现数据的输入和输出功能。<br>        Presenter：表示器，用于连接M层、V层，完成Model层与View层的交互，还可以进行业务逻辑的处理。</p>
<p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/2e5c150305574d5788fda5f759dfbeb4.png"></p>
<h6 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h6><p>1、View层收到用户的操作<br>2、View层把用户的操作交给Presenter<br>3、Presenter直接操作Model层进行业务逻辑处理<br>4、Model层处理完毕后，通知Presenter<br>5、Presenter收到通知后，去更新View层<br>        在MVP模式中，Model与View无法直接进行交互，所以Presenter层会从Model层获得数据，适当处理后交给View层进行显示<br>在MVP模式中，Presenter层将View层和Model层进行隔离，使View和Model之间不存在耦合，同时将业务逻辑从View层剥离</p>
<h6 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h6><p>​		可以更高效的使用Model，所有的交互都发生在——Presenter内部<br>将一个Presenter用于多个视图，而不需要改变Presenter的逻辑，View变化比Model变化频繁，逻辑结构清晰，View层代码不再臃肿</p>
<h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h6><p>1、MVP模式基于接口设计，会增加很多类，代码逻辑虽然清晰，但代码量庞大2、MVP适用于中小型项目，大型项目慎用<br>3、MVC和MVP的主要区别：<br>4、MVP中View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互<br>5、MVP中Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View<br>6、MVP中Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。<br>7、MVC中View可以与Model直接交互，通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑</p>
<h5 id="MVVM："><a href="#MVVM：" class="headerlink" title="MVVM："></a>MVVM：</h5><p>MVVM 即 Model-View-ViewModel<br>        M——Model（模型）实体模型，定义实体类，获取业务数据模型，如通过数据库或者网络来操作数据等<br>        V——View（视图）布局文件(XML），主要进行控件的初始化设置<br>        VM——ViewModel（控制器）：连接 View 与 Model 的中间桥梁，ViewModel 与 Model 直接交互，通过DataBinding将数据变化反应给View</p>
<p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/565ccf0115fe47e0afb2fe819a7c7e6d.png"></p>
<p> 存在两个方向都实现的情况，叫做数据的双向绑定。双向数据绑定可以说是一个模板引擎，它会根据数据的变化实时渲染。如图3.3所示，View层和Model层之间的修改都会同步到对方。</p>
<p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/7682203377974fb6a025bb85877893aa.png"></p>
<h6 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h6><ol>
<li>结构清晰，职责划分清晰</li>
<li>模块间充分解耦</li>
<li>在 MVP 的基础上，MVVM 把 View 和 ViewModel 也进行了解耦</li>
</ol>
<h6 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h6><p>1、定位问题困难</p>
<p>从MVC到MVP再到MVVM，这是一个不断进步的过程，后两者都是在MVC基础上发展而来，使用起来更加方便。这三者主要的区别在于除Model层和View层之外的第三层的不同。</p>
<hr>
<h2 id="21、你了解Vue-js吗？"><a href="#21、你了解Vue-js吗？" class="headerlink" title="21、你了解Vue.js吗？"></a>21、你了解Vue.js吗？</h2><h5 id="1）、vueJS是基于MVVM的JS框架"><a href="#1）、vueJS是基于MVVM的JS框架" class="headerlink" title="1）、vueJS是基于MVVM的JS框架"></a>1）、vueJS是基于MVVM的JS框架</h5><h5 id="2）、有（常见的）13个指令："><a href="#2）、有（常见的）13个指令：" class="headerlink" title="2）、有（常见的）13个指令："></a>2）、有（常见的）13个指令：</h5><h5 id="3）、有（常见的）8个配置项：el，data，computed，watch，components，filter，directives，mixins"><a href="#3）、有（常见的）8个配置项：el，data，computed，watch，components，filter，directives，mixins" class="headerlink" title="3）、有（常见的）8个配置项：el，data，computed，watch，components，filter，directives，mixins"></a>3）、有（常见的）8个配置项：el，data，computed，watch，components，filter，directives，mixins</h5><h5 id="4）、vue实例生命周期分为四个阶段，八个生命周期函数"><a href="#4）、vue实例生命周期分为四个阶段，八个生命周期函数" class="headerlink" title="4）、vue实例生命周期分为四个阶段，八个生命周期函数"></a>4）、vue实例生命周期分为四个阶段，八个生命周期函数</h5><h5 id="5）、vue做项目时会用到的全家桶技术：vueJS框架，vueX，vue-router，aixos，vant组件库等等"><a href="#5）、vue做项目时会用到的全家桶技术：vueJS框架，vueX，vue-router，aixos，vant组件库等等" class="headerlink" title="5）、vue做项目时会用到的全家桶技术：vueJS框架，vueX，vue-router，aixos，vant组件库等等"></a>5）、vue做项目时会用到的全家桶技术：vueJS框架，vueX，vue-router，aixos，vant组件库等等</h5><hr>
<h2 id="22、Vue-router的两种路由模式的区别"><a href="#22、Vue-router的两种路由模式的区别" class="headerlink" title="22、Vue-router的两种路由模式的区别"></a>22、Vue-router的两种路由模式的区别</h2><p>路由模式分为两种：hash和history；通过设置vueRouter对象的mode属性来完成修改。</p>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><h5 id="1）、外观上："><a href="#1）、外观上：" class="headerlink" title="1）、外观上："></a>1）、外观上：</h5><h6 id="hash模式时，路径上由"><a href="#hash模式时，路径上由" class="headerlink" title="hash模式时，路径上由#"></a>hash模式时，路径上由#</h6><h6 id="history模式时，路径上没有"><a href="#history模式时，路径上没有" class="headerlink" title="history模式时，路径上没有#"></a>history模式时，路径上没有#</h6><h5 id="2）、原理上"><a href="#2）、原理上" class="headerlink" title="2）、原理上"></a>2）、原理上</h5><h6 id="（1）、hash模式通过修改location-href来完成"><a href="#（1）、hash模式通过修改location-href来完成" class="headerlink" title="（1）、hash模式通过修改location.href来完成"></a>（1）、hash模式通过修改location.href来完成</h6><p>使用锚点连接的思路，使用hash模式不会给后端发请求。当然，在hash值变化时，会同时触发window对象的onhashchange事件，并可以通过事件对象的oldURL属性和newURL属性 得到新旧URL。</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;
    &lt;div&gt;
        &lt;a href="#p01" &gt;p01&lt;/a&gt;&lt;br/&gt;
        &lt;a href="#p02" &gt;p02&lt;/a&gt;&lt;br/&gt;
        &lt;a href="#p03" &gt;p03&lt;/a&gt;
    &lt;/div&gt;
    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
    &lt;a name="p01"&gt;我是第一个p&lt;/a&gt;
    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
    &lt;a name="p02"&gt;我是第二个p&lt;/a&gt;
    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
    &lt;a name="p03"&gt;我是第三个p&lt;/a&gt;
    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
window.onhashchange = function(event){
    console.log("旧url",event.oldURL);
    console.log("新的url",event.newURL);
}
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h6 id="（2）、通过修改history-pushState来完成"><a href="#（2）、通过修改history-pushState来完成" class="headerlink" title="（2）、通过修改history.pushState来完成"></a>（2）、通过修改history.pushState来完成</h6><p>例：</p>
<pre class="line-numbers language-none"><code class="language-none">window.history.pushState(null,null,"p01.html");

window.location.reload();//想测试的话，尽量加上这句话，要不然，地址变了，但是页面并没有出现。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>history模式会给后端发请求（如果刷新当前页面的话），一旦，后端和前端提供了同样的路径，那么，浏览器的请求结果就会有问题，到底是后端的资源还是前端的资源（不同的后端处理思路不停），还好，我们一般在后端apiserver的请求路径的前面习惯性的有个 /api。</p>
<p>所以，由于不同服务端的处理思路不同。所以，需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面（单页面），这个页面就是你 app 依赖的页面。否则，就会返回404。</p>
<p>你可以改成history的模式，测试一下，如果刷新当前页面，那么，浏览器会朝后端发送请求（给当前路径）。</p>
<hr>
<h2 id="23、Vue路由守卫的三种方式，及其钩子函数和参数"><a href="#23、Vue路由守卫的三种方式，及其钩子函数和参数" class="headerlink" title="23、Vue路由守卫的三种方式，及其钩子函数和参数"></a>23、Vue路由守卫的三种方式，及其钩子函数和参数</h2><h4 id="1）、全局守卫"><a href="#1）、全局守卫" class="headerlink" title="1）、全局守卫"></a>1）、全局守卫</h4><p>全局守卫由前置守卫和后置守卫，是VueRouter对象的两个钩子函数，分别是beforeEach和afterEach。</p>
<h5 id="前置守卫："><a href="#前置守卫：" class="headerlink" title="前置守卫："></a>前置守卫：</h5><pre class="line-numbers language-none"><code class="language-none">router.beforeEach((to, from, next) =&gt; {
    //  to: 目标路由
    //  from: 当前路由

    // next() 跳转  一定要调用
    next(false);//不让走
    next(true);//继续前行
    next('/login')//走哪
    next({path:'/detail/2',params:{},query:{}})//带点货
 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="后置守卫："><a href="#后置守卫：" class="headerlink" title="后置守卫："></a>后置守卫：</h5><pre class="line-numbers language-none"><code class="language-none">router.afterEach((to,from)=&gt;{
  //全局后置守卫业务
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h6 id="x2F-x2F-过程：-1、请求一个路径：如：-x2F-Index-2、经历前置守卫-决定了能去哪个路径-3、根据去的路径，找对应component（路由配置）-4、经过后置守卫-5、创建组件"><a href="#x2F-x2F-过程：-1、请求一个路径：如：-x2F-Index-2、经历前置守卫-决定了能去哪个路径-3、根据去的路径，找对应component（路由配置）-4、经过后置守卫-5、创建组件" class="headerlink" title="//过程： 1、请求一个路径：如：/Index 2、经历前置守卫 决定了能去哪个路径 3、根据去的路径，找对应component（路由配置） 4、经过后置守卫 5、创建组件"></a>//过程： 1、请求一个路径：如：/Index 2、经历前置守卫 决定了能去哪个路径 3、根据去的路径，找对应component（路由配置） 4、经过后置守卫 5、创建组件</h6><h4 id="2）、路由独享守卫"><a href="#2）、路由独享守卫" class="headerlink" title="2）、路由独享守卫"></a>2）、路由独享守卫</h4><p>写在路由配置里。钩子函数名：beforeEnter，只有前置守卫</p>
<p>例：</p>
<pre class="line-numbers language-none"><code class="language-none">
// src/router/index.js
{
  path: '/user',
  component: User,
  beforeEnter: (to,from,next)=&gt;{ //路由独享守卫 前置 
    console.log('路由独享守卫');
    if(Math.random()&lt;.5){
      next()
    }else{
      next('/login')
    }
  }
 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3）、组件内部守卫"><a href="#3）、组件内部守卫" class="headerlink" title="3）、组件内部守卫"></a>3）、组件内部守卫</h4><p>写在组件对象里。分别有前置守卫，后置守卫，路由改变守卫（当前组件被复用的情况,不是路径改变）三个钩子函数。</p>
<pre class="line-numbers language-none"><code class="language-none">export default{
    data(){return {}}
  ……………………  

    //组件内部钩子
    beforeRouteEnter (to, from, next) {//前置
      // 不！能！获取组件实例 `this`
      // 因为当守卫执行前，组件实例还没被创建
    },
    beforeRouteUpdate (to, from, next) {
      // 在当前路由改变，但是该组件被复用时调用
      // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
      // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
      // 可以访问组件实例 `this`
    },
    beforeRouteLeave (to, from, next) {//后置
      // 导航离开该组件的对应路由时调用
      // 可以访问组件实例 `this`
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="24、为何Vue采用异步渲染？"><a href="#24、为何Vue采用异步渲染？" class="headerlink" title="24、为何Vue采用异步渲染？"></a>24、为何Vue采用异步渲染？</h2><h4 id="1、vue采用异步队列渲染是为了提高性能，在异步队里会去掉重复的无效的渲染。"><a href="#1、vue采用异步队列渲染是为了提高性能，在异步队里会去掉重复的无效的渲染。" class="headerlink" title="1、vue采用异步队列渲染是为了提高性能，在异步队里会去掉重复的无效的渲染。"></a>1、vue采用异步队列渲染是为了提高性能，在异步队里会去掉重复的无效的渲染。</h4><h6 id="当vue中的数据发生改变后，vue框架会把该数据引起的dom更新放入异步队列（-缓冲在同一事件循环中发生的所有数据变更-），进行排队。-如果同一个-watcher-被多次触发，只会被推入到队列中一次-。-这种在缓冲时去除重复数据对于避免不必要的计算和-DOM-操作是非常重要的-。"><a href="#当vue中的数据发生改变后，vue框架会把该数据引起的dom更新放入异步队列（-缓冲在同一事件循环中发生的所有数据变更-），进行排队。-如果同一个-watcher-被多次触发，只会被推入到队列中一次-。-这种在缓冲时去除重复数据对于避免不必要的计算和-DOM-操作是非常重要的-。" class="headerlink" title="当vue中的数据发生改变后，vue框架会把该数据引起的dom更新放入异步队列（ 缓冲在同一事件循环中发生的所有数据变更 ），进行排队。 如果同一个 watcher 被多次触发，只会被推入到队列中一次 。 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的 。"></a>当vue中的数据发生改变后，vue框架会把该数据引起的dom更新放入异步队列（ 缓冲在同一事件循环中发生的所有数据变更 ），进行排队。 如果同一个 watcher 被多次触发，只会被推入到队列中一次 。 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的 。</h6><h4 id="2、如果不采用异步渲染，而是在数据发生改变后，立即更新dom，如果有重复无效的渲染，那么，就会造成性能的浪费。"><a href="#2、如果不采用异步渲染，而是在数据发生改变后，立即更新dom，如果有重复无效的渲染，那么，就会造成性能的浪费。" class="headerlink" title="2、如果不采用异步渲染，而是在数据发生改变后，立即更新dom，如果有重复无效的渲染，那么，就会造成性能的浪费。"></a>2、如果不采用异步渲染，而是在数据发生改变后，立即更新dom，如果有重复无效的渲染，那么，就会造成性能的浪费。</h4><hr>
<h2 id="25、nextTick实现原理？"><a href="#25、nextTick实现原理？" class="headerlink" title="25、nextTick实现原理？"></a>25、nextTick实现原理？</h2><h4 id="1）、为什么用Vue-nextTick"><a href="#1）、为什么用Vue-nextTick" class="headerlink" title="1）、为什么用Vue.nextTick()"></a>1）、为什么用Vue.nextTick()</h4><h5 id="首先，JS是单线程的，那么，它如何处理异步操作。"><a href="#首先，JS是单线程的，那么，它如何处理异步操作。" class="headerlink" title="首先，JS是单线程的，那么，它如何处理异步操作。"></a>首先，JS是单线程的，那么，它如何处理异步操作。</h5><ul>
<li>所有同步任务都在主线程上执行，形成一个<strong>执行栈</strong>。</li>
<li>主线程之外，会存在一个<strong>任务队列</strong>，只要异步任务有了结果，就在任务队列中放置一个事件（所以，也叫事件队列），进行<strong>排队</strong>（处于等待状态）</li>
<li>当执行栈中的所有同步任务执行完成，就会<strong>读取</strong>任务队列（事件队列）中的任务（事件）。即：任务队列中的任务就结束了等待状态，<strong>进入</strong>执行栈</li>
<li>主线程不断重复第三步。直到任务队列和执行栈里的代码执行完毕。</li>
</ul>
<p>其次，vue更新DOM的思路。使用的就是异步更新队列，所以，就使用了事件循环。目的是提高性能，避免无效的重复的DOM更新。即：vue中更新数据后，并不会立即更新DOM，而是把数据引起的DOM更新放入到异步更新队列里。等待下次事件循环（tick），并在两个tick之间进行UI渲染。这样程序员就不能在更改数据后，立即获取更新后的DOM，也不知道什么时候DOM能够更新。基于此，vue提供了nextTick函数。让程序员操作更新后DOM的代码放入到nextTick的回调函数里。由nextTick内部，在更新完DOM后，调用回调函数。</p>
<p>示例代码：</p>
<pre class="line-numbers language-none"><code class="language-none">
this.msg = "hello"
this.$nextTick(()=&gt;{
     操作更新后DOM的代码。
});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2）、什么是Vue-nextTick"><a href="#2）、什么是Vue-nextTick" class="headerlink" title="2）、什么是Vue.nextTick()"></a>2）、什么是Vue.nextTick()</h4><p>Vue.nextTick的代码思路示意</p>
<pre class="line-numbers language-none"><code class="language-none">function nextTick(cb){
	//DOM 更新
	cb()
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>那么，Vue是如何知道DOM更新了？</p>
<ul>
<li>MutationObserver：这是HTML5新增的API。用于监视DOM变动的接口，它可以监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等</li>
<li>另外，考虑到，微任务比宏任务耗时少，浏览器的兼容性。所以，vue中延迟调用优先级如下： Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout</li>
</ul>
<h4 id="3）、应用场景："><a href="#3）、应用场景：" class="headerlink" title="3）、应用场景："></a>3）、应用场景：</h4><h6 id="在Vue生命周期的created-钩子函数里，如果要进行DOM操作，一定要把DOM操作放在Vue-nextTick-的回调函数中。"><a href="#在Vue生命周期的created-钩子函数里，如果要进行DOM操作，一定要把DOM操作放在Vue-nextTick-的回调函数中。" class="headerlink" title="在Vue生命周期的created()钩子函数里，如果要进行DOM操作，一定要把DOM操作放在Vue.nextTick()的回调函数中。"></a>在Vue生命周期的created()钩子函数里，如果要进行DOM操作，一定要把DOM操作放在Vue.nextTick()的回调函数中。</h6><h6 id="在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue-nextTick-的回调函数中。"><a href="#在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue-nextTick-的回调函数中。" class="headerlink" title="在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue.nextTick()的回调函数中。"></a>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue.nextTick()的回调函数中。</h6><hr>
<h2 id="26、JS的事件循环"><a href="#26、JS的事件循环" class="headerlink" title="26、JS的事件循环"></a>26、JS的事件循环</h2><h4 id="JS是单线程的，那么，它如何处理异步操作？"><a href="#JS是单线程的，那么，它如何处理异步操作？" class="headerlink" title="JS是单线程的，那么，它如何处理异步操作？"></a>JS是单线程的，那么，它如何处理异步操作？</h4><h5 id="答：使用事件循环，执行过程如下："><a href="#答：使用事件循环，执行过程如下：" class="headerlink" title="答：使用事件循环，执行过程如下："></a>答：使用事件循环，执行过程如下：</h5><ul>
<li><p>所有</p>
</li>
<li><p>所有同步任务都在主线程上执行，形成一个执行栈。</p>
</li>
<li><p>主线程之外，会存在一个任务队列，只要异步任务有了结果（如：setTimeout的等待时间到了），就在任务队列中放置一个事件（所以，也叫事件队列），进行排队（处于等待状态）。</p>
</li>
<li><p>当执行栈中的所有同步任务执行完后，就会读取任务队列（事件队列）中的任务（事件）。即：任务队列中的任务就结束了等待状态，进入执行栈。</p>
</li>
<li><p>主线程不断重复第三步。直到任务队列和执行栈里的代码执行完毕。</p>
<h4 id="1、执行栈"><a href="#1、执行栈" class="headerlink" title="1、执行栈"></a>1、执行栈</h4><p>注意，执行栈不是内存的栈区。</p>
<p>在JS中，当很多函数被依次调用的时候，因为js是单线程的，同一时间只能执行一个函数，怎么办？不能同时来，得排个队，排个一子队，按照顺序来，那这个一子队的顺序，即哪个函数在前，哪个函数在后，谁来记录呢？js为此专门开辟了一个内存区域，起名叫做执行栈。在执行栈里，保存着即将要执行的函数。就像大家在学校里排队打饭一样，只有一个人给你打饭时，你就老老实实地排队，一个打完饭了，下一个再打。</p>
<p>​		当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个函数，那么js会向执行栈中添加这个函数的执行环境（当我们调用一个函数的时候，js会生成一个与这个函数对应的执行环境（context），又叫执行上下文。这个执行环境中保存着这个函数的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。），然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p>
<h4 id="2、事件队列"><a href="#2、事件队列" class="headerlink" title="2、事件队列"></a>2、事件队列</h4><p> 以上说的是同步执行的情况，如果出现了异步（如发送ajax请求数据）执行，就需要用到事件队列，或者叫做任务队列（Task Queue）。</p>
<p> js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中下面的任务。执行过程中，当这个异步事件被触发时（异步任务有了结果，如setTimeout的等待世间到了），把该事件加入一个队列里，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>
<p>即：执行栈存放所有要执行的函数（代码），事件队列中存放所有的异步任务，如果执行栈中的代码执行完毕后，才会把事件队列中的事件（所有异步的代码）放入执行栈，接着执行。</p>
</li>
</ul>
<p>这也是为什么如下代码的执行，与你想象的不一样的原因所在。</p>
<pre><code>          setTimeout（function(){

                     console.log(1);
             }, 0）

             console.log(2);
</code></pre>
<p>的执行结果是在后台分别打印出： 2   1</p>
<p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/20190714174959220.png"></p>
<h4 id="3、事件队列里分为：宏任务队列和微任务队列"><a href="#3、事件队列里分为：宏任务队列和微任务队列" class="headerlink" title="3、事件队列里分为：宏任务队列和微任务队列"></a>3、事件队列里分为：宏任务队列和微任务队列</h4><h5 id="1）、宏任务（macrotask）"><a href="#1）、宏任务（macrotask）" class="headerlink" title="1）、宏任务（macrotask）"></a>1）、宏任务（macrotask）</h5><h6 id="宏任务一般包括：-setTimeout，setInterval，I-x2F-O-操作（包括AJAX请求），即上面的示例中setTimeout是宏任务。"><a href="#宏任务一般包括：-setTimeout，setInterval，I-x2F-O-操作（包括AJAX请求），即上面的示例中setTimeout是宏任务。" class="headerlink" title="宏任务一般包括： setTimeout，setInterval，I/O 操作（包括AJAX请求），即上面的示例中setTimeout是宏任务。"></a>宏任务一般包括： setTimeout，setInterval，I/O 操作（包括AJAX请求），即上面的示例中setTimeout是宏任务。</h6><h5 id="2）、微任务（microtask）"><a href="#2）、微任务（microtask）" class="headerlink" title="2）、微任务（microtask）"></a>2）、微任务（microtask）</h5><h6 id="微任务一般包括：promise-then-里的操作"><a href="#微任务一般包括：promise-then-里的操作" class="headerlink" title="微任务一般包括：promise.then()里的操作"></a>微任务一般包括：promise.then()里的操作</h6><h4 id="4、当宏任务碰到了微任务时"><a href="#4、当宏任务碰到了微任务时" class="headerlink" title="4、当宏任务碰到了微任务时"></a>4、当宏任务碰到了微任务时</h4><p>那么问题来了，当执行栈里的代码执行完毕，去事件队列里取任务时，先去微任务队列里的任务还是先去宏任务里的任务呢？</p>
<h6 id="答：先取微任务里的任务。因为，微任务耗时少，快。"><a href="#答：先取微任务里的任务。因为，微任务耗时少，快。" class="headerlink" title="答：先取微任务里的任务。因为，微任务耗时少，快。"></a>答：先取微任务里的任务。因为，微任务耗时少，快。</h6><h4 id="5、示例：当宏任务碰到了微任务时"><a href="#5、示例：当宏任务碰到了微任务时" class="headerlink" title="5、示例：当宏任务碰到了微任务时"></a>5、示例：当宏任务碰到了微任务时</h4><pre class="line-numbers language-none"><code class="language-none">console.log(1); //主线程
 
setTimeout(function(){
    console.log(2);//这个是宏任务，不管时间是多少（就算是0），都会进入到宏任务
},0);
 
new Promise(function(resolve,reject){
    resolve();//这个是then的回调函数，这个会进入到微任务
})
.then(function(){
    console.log(3);
});
 
console.log(4);//主线程
 
 
 
// 以上打印结果是：1,4,3,2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="6、示例：当宏任务碰到了微任务时"><a href="#6、示例：当宏任务碰到了微任务时" class="headerlink" title="6、示例：当宏任务碰到了微任务时"></a>6、示例：当宏任务碰到了微任务时</h4><p>多啰嗦一句，注意：在Promise的回调函数里的代码是同步，then里的回调才是异步的（resolve()）</p>
<pre class="line-numbers language-none"><code class="language-none">console.log(1); //主线程
 
setTimeout(function(){
    console.log(2);//这个是宏任务，不管时间是多少（就算是0），也会进入到宏任务
},0);
 
new Promise(function(resolve,reject){
    console.log(3); //Promise里的代码是同步的 （这行代码是新加的），所以，一开始在主线程执行
    resolve();//这个是then的回调函数，这个是进入到微任务
})
.then(function(){
    console.log(4);
});
 
console.log(5);
 
// 以上打印结果是：1,3,5,4,2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="7、示例：Promise，async，await，setTimeout"><a href="#7、示例：Promise，async，await，setTimeout" class="headerlink" title="7、示例：Promise，async，await，setTimeout"></a>7、示例：Promise，async，await，setTimeout</h4><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    
&lt;/body&gt;
&lt;/html&gt;
&lt;script&gt;
 
console.log(0); //主线程
 
setTimeout(function(){
    console.log(1);//宏任务
},1000);
 
setTimeout(function(){
    console.log(2);//宏任务
},0);
 
new Promise(function(resolve,reject){
    console.log(3);//主线程
    resolve(); //微任务
}).then(()=&gt;{
    console.log(4);//微任务，这个then里的回调代码就是resolve
}); 
 
async function async1(){
    console.log(5); //同步，主线程
    let temp =  await async2(); //async2函数里有promise
    console.log(temp);
    console.log(6);
    return "async1";
}
 
async function async2(){
    console.log(7); //同步
    return "async2";
}
 
async1();
 
console.log(8);//主线程，
 
// 以上打印结果是：0，3，5，7，8，4，async2里的promise.then(), 6, async1里的promise.then(),2,1
 
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="27、何时需要使用beforeDestroy？"><a href="#27、何时需要使用beforeDestroy？" class="headerlink" title="27、何时需要使用beforeDestroy？"></a>27、何时需要使用beforeDestroy？</h2><p>总体来说，需要清除的是：当前组件不会自动销毁的数据（不属于当前组件的数据），并且该数据只是在当前组件里使用。</p>
<h6 id="1）、清楚定时器（定时器是window对象的，不主动清楚，是不会清楚的）"><a href="#1）、清楚定时器（定时器是window对象的，不主动清楚，是不会清楚的）" class="headerlink" title="1）、清楚定时器（定时器是window对象的，不主动清楚，是不会清楚的）"></a>1）、清楚定时器（定时器是window对象的，不主动清楚，是不会清楚的）</h6><h6 id="2）、-on方法，那需要在组件销毁前解绑。（-on虽然属于Vue的实例方法，但是，这个实例很有可能不是当前vue组件（如：事件总线中的用法））"><a href="#2）、-on方法，那需要在组件销毁前解绑。（-on虽然属于Vue的实例方法，但是，这个实例很有可能不是当前vue组件（如：事件总线中的用法））" class="headerlink" title="2）、$on方法，那需要在组件销毁前解绑。（$on虽然属于Vue的实例方法，但是，这个实例很有可能不是当前vue组件（如：事件总线中的用法））"></a>2）、$on方法，那需要在组件销毁前解绑。（$on虽然属于Vue的实例方法，但是，这个实例很有可能不是当前vue组件（如：事件总线中的用法））</h6><h6 id="3）、解除事件的绑定-scroll-mousemove（这些事件是绑定在window对象或者document对象上的）"><a href="#3）、解除事件的绑定-scroll-mousemove（这些事件是绑定在window对象或者document对象上的）" class="headerlink" title="3）、解除事件的绑定 scroll mousemove（这些事件是绑定在window对象或者document对象上的）"></a>3）、解除事件的绑定 scroll mousemove（这些事件是绑定在window对象或者document对象上的）</h6><hr>
<h2 id="28、Vue中的-v-html会导致哪些问题"><a href="#28、Vue中的-v-html会导致哪些问题" class="headerlink" title="28、Vue中的 v-html会导致哪些问题"></a>28、Vue中的 v-html会导致哪些问题</h2><h6 id="1）、可能会导致XSS攻击。因为V-html更新的是元素的innerHTML。内容按普通-HTML-插入，-不会作为-Vue-模板进行编译-。"><a href="#1）、可能会导致XSS攻击。因为V-html更新的是元素的innerHTML。内容按普通-HTML-插入，-不会作为-Vue-模板进行编译-。" class="headerlink" title="1）、可能会导致XSS攻击。因为V-html更新的是元素的innerHTML。内容按普通 HTML 插入， 不会作为 Vue 模板进行编译 。"></a>1）、可能会导致XSS攻击。因为V-html更新的是元素的innerHTML。内容按普通 HTML 插入， 不会作为 Vue 模板进行编译 。</h6><h6 id="2）、在单文件组件里，scoped的样式不会应用在v-html内部。因为那部分HTML没有被Vue的模板编辑器处理。怎么解决呢？如果你希望针对-v-html-的内容设置带······作用域的-CSS，你可以替换为-CSS-Modules-或用一个额外的全局-元素手动设置类似-BEM-的作用域策略。"><a href="#2）、在单文件组件里，scoped的样式不会应用在v-html内部。因为那部分HTML没有被Vue的模板编辑器处理。怎么解决呢？如果你希望针对-v-html-的内容设置带······作用域的-CSS，你可以替换为-CSS-Modules-或用一个额外的全局-元素手动设置类似-BEM-的作用域策略。" class="headerlink" title="2）、在单文件组件里，scoped的样式不会应用在v-html内部。因为那部分HTML没有被Vue的模板编辑器处理。怎么解决呢？如果你希望针对 v-html 的内容设置带······作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局 元素手动设置类似 BEM 的作用域策略。"></a>2）、在单文件组件里，scoped的样式不会应用在v-html内部。因为那部分HTML没有被Vue的模板编辑器处理。怎么解决呢？如果你希望针对 v-html 的内容设置带······作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局 元素手动设置类似 BEM 的作用域策略。</h6><h6 id="3）、后台返回的html片段，以及CSS样式和JS，但是返回的JS是不执行的，因为浏览器在渲染的时候并没有将JS渲染，这时要在-nextTick中动态创建script标签并插入"><a href="#3）、后台返回的html片段，以及CSS样式和JS，但是返回的JS是不执行的，因为浏览器在渲染的时候并没有将JS渲染，这时要在-nextTick中动态创建script标签并插入" class="headerlink" title="3）、后台返回的html片段，以及CSS样式和JS，但是返回的JS是不执行的，因为浏览器在渲染的时候并没有将JS渲染，这时要在$nextTick中动态创建script标签并插入"></a>3）、后台返回的html片段，以及CSS样式和JS，但是返回的JS是不执行的，因为浏览器在渲染的时候并没有将JS渲染，这时要在$nextTick中动态创建script标签并插入</h6><hr>
<h6 id="29、为什么v-for与v-if不能连用"><a href="#29、为什么v-for与v-if不能连用" class="headerlink" title="29、为什么v-for与v-if不能连用"></a>29、为什么v-for与v-if不能连用</h6><p>应该说，建议不要连用，或者说，在循环时，通过if只能拿到少部分数据时，建议不要使用。</p>
<h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><h6 id="v-for比v-if优先级高，如果遍历的数组元素个数比较多，但是满足v-if条件比较少的情况下。会浪费性能。而且，每次刷新页面时，都会执行这样性能不高的代码。"><a href="#v-for比v-if优先级高，如果遍历的数组元素个数比较多，但是满足v-if条件比较少的情况下。会浪费性能。而且，每次刷新页面时，都会执行这样性能不高的代码。" class="headerlink" title="v-for比v-if优先级高，如果遍历的数组元素个数比较多，但是满足v-if条件比较少的情况下。会浪费性能。而且，每次刷新页面时，都会执行这样性能不高的代码。"></a>v-for比v-if优先级高，如果遍历的数组元素个数比较多，但是满足v-if条件比较少的情况下。会浪费性能。而且，每次刷新页面时，都会执行这样性能不高的代码。</h6><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><h6 id="可以在computed里循环数组，通过filter的方式，过滤出需要的数据。v-for直接循环计算属性的结果（不用v-if）。而computed是有缓存的，所以，在原始数据没有变化时，不会多次过滤数据，这样，就提高了效率。"><a href="#可以在computed里循环数组，通过filter的方式，过滤出需要的数据。v-for直接循环计算属性的结果（不用v-if）。而computed是有缓存的，所以，在原始数据没有变化时，不会多次过滤数据，这样，就提高了效率。" class="headerlink" title="可以在computed里循环数组，通过filter的方式，过滤出需要的数据。v-for直接循环计算属性的结果（不用v-if）。而computed是有缓存的，所以，在原始数据没有变化时，不会多次过滤数据，这样，就提高了效率。"></a>可以在computed里循环数组，通过filter的方式，过滤出需要的数据。v-for直接循环计算属性的结果（不用v-if）。而computed是有缓存的，所以，在原始数据没有变化时，不会多次过滤数据，这样，就提高了效率。</h6><p>示例：</p>
<pre class="line-numbers language-none"><code class="language-none">computed:{
    isCompleteTask:function(){
        return this.todos.filter(item=&gt;item.isComplete);
    }          
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h2 id="31、如何自定义v-model"><a href="#31、如何自定义v-model" class="headerlink" title="31、如何自定义v-model"></a>31、如何自定义v-model</h2><p>答：使用vue组件中的选项model。</p>
<p>首先，官方组件里可以使用v-model。而且，vue框架针对官方组件（文本框，单选钮，复选框，下拉框）都有绑定的属性和事件。如：文本框所绑定的属性是value，绑定的事件是input。</p>
<p>那么，自定义组件里，如何使用v-model指令。</p>
<h5 id="1、自定义组件里使用v-model指令，默认会使用value属性和input事件。"><a href="#1、自定义组件里使用v-model指令，默认会使用value属性和input事件。" class="headerlink" title="1、自定义组件里使用v-model指令，默认会使用value属性和input事件。"></a>1、自定义组件里使用v-model指令，默认会使用value属性和input事件。</h5><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
 
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;p&gt;{{str}}&lt;/p&gt;
        &lt;hr/&gt;
         &lt;chat v-model="str" &gt;&lt;/chat&gt;
    &lt;/div&gt;
    &lt;hr /&gt;
&lt;/body&gt;
 
&lt;/html&gt;
&lt;script src="./js/vue2.js"&gt;&lt;/script&gt;
&lt;script&gt;
Vue.component("chat",{
    props:["value"],    
    template:`
        &lt;div&gt;
            &lt;p&gt;{{value}}&lt;/p&gt;
            &lt;input type="text"  /&gt;
            &lt;input type="button" value="修改value" @click="changeVal"  /&gt;            
        &lt;/div&gt;
    `,
    data(){
        return {}
    },
    methods:{
        changeVal(){
            this.$emit("input","新值");
        }
    }
})
 
let vm = new Vue({
    el:"#app",
    data:{
        str:"hello str"
    }
})
 
 
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2、如果，想修改属性名和事件名，就需要在VUE组件里增加model选项。"><a href="#2、如果，想修改属性名和事件名，就需要在VUE组件里增加model选项。" class="headerlink" title="2、如果，想修改属性名和事件名，就需要在VUE组件里增加model选项。"></a>2、如果，想修改属性名和事件名，就需要在VUE组件里增加model选项。</h5><p>示例：</p>
<pre class="line-numbers language-none"><code class="language-none">Vue.component('my-checkbox', {
  props:['ccc','ddd'],//声明了自定义组件的属性。
  model: {
    prop: 'ccc', //表示v-model所绑定的属性是 ccc
    event: 'change'//表示v-model所绑定的事件是是 change
  },
  ……………………
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">StayAwake</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://stayawake9.github.io/2023/01/27/mian-shi-ti-he-ji-vue/">https://stayawake9.github.io/2023/01/27/mian-shi-ti-he-ji-vue/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">StayAwake</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">
                                    <span class="chip bg-color">面试题</span>
                                </a>
                            
                                <a href="/tags/VUE/">
                                    <span class="chip bg-color">VUE</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2023/01/27/mian-shi-ti-he-ji-vue/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="面试题合集-VUE">
                        
                        <span class="card-title">面试题合集-VUE</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-01-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            StayAwake
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <span class="chip bg-color">面试题</span>
                    </a>
                    
                    <a href="/tags/VUE/">
                        <span class="chip bg-color">VUE</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/01/17/mian-shi-ti-he-ji-js/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="面试题合集--JS">
                        
                        <span class="card-title">面试题合集--JS</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-01-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            StayAwake
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <span class="chip bg-color">面试题</span>
                    </a>
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2328646086"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2023</span>
            
            <a href="/about" target="_blank">StayAwake</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">18.1k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "12";
                        var startDate = "14";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已夹缝中生存 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已夹缝中生存 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已夹缝中生存 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已夹缝中生存 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/stayAwake9" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:zbh709@126.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1327859025" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1327859025" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
