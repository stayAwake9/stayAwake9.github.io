<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题合集-VUE</title>
      <link href="/2023/01/27/mian-shi-ti-he-ji-vue/"/>
      <url>/2023/01/27/mian-shi-ti-he-ji-vue/</url>
      
        <content type="html"><![CDATA[<h1 id="VUE2面试题系类"><a href="#VUE2面试题系类" class="headerlink" title="VUE2面试题系类"></a>VUE2面试题系类</h1><h2 id="1、v-show与v-if有什么区别？"><a href="#1、v-show与v-if有什么区别？" class="headerlink" title="1、v-show与v-if有什么区别？"></a>1、v-show与v-if有什么区别？</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3><h5 id="v-show和v-if都是控制dom元素的显示和隐藏。"><a href="#v-show和v-if都是控制dom元素的显示和隐藏。" class="headerlink" title="v-show和v-if都是控制dom元素的显示和隐藏。"></a>v-show和v-if都是控制dom元素的显示和隐藏。</h5><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><h5 id="1、原理："><a href="#1、原理：" class="headerlink" title="1、原理："></a>1、原理：</h5><h5 id="v-show时通过控制元素的样式属性display的值，来完成显示和隐藏；"><a href="#v-show时通过控制元素的样式属性display的值，来完成显示和隐藏；" class="headerlink" title="v-show时通过控制元素的样式属性display的值，来完成显示和隐藏；"></a>v-show时通过控制元素的样式属性display的值，来完成显示和隐藏；</h5><h5 id="v-if是通过对dom元素的添加和删除来完成显示和隐藏"><a href="#v-if是通过对dom元素的添加和删除来完成显示和隐藏" class="headerlink" title="v-if是通过对dom元素的添加和删除来完成显示和隐藏"></a>v-if是通过对dom元素的添加和删除来完成显示和隐藏</h5><h5 id="2、使用场景：由原理（做法）得出使用场景的区别"><a href="#2、使用场景：由原理（做法）得出使用场景的区别" class="headerlink" title="2、使用场景：由原理（做法）得出使用场景的区别"></a>2、使用场景：由原理（做法）得出使用场景的区别</h5><h5 id="v-show：使用在dom元素频繁切换的场景"><a href="#v-show：使用在dom元素频繁切换的场景" class="headerlink" title="v-show：使用在dom元素频繁切换的场景"></a>v-show：使用在dom元素频繁切换的场景</h5><h5 id="v-if：当dom元素的切换不频繁，可以使用。特别是，首次元素处于隐藏的情况下"><a href="#v-if：当dom元素的切换不频繁，可以使用。特别是，首次元素处于隐藏的情况下" class="headerlink" title="v-if：当dom元素的切换不频繁，可以使用。特别是，首次元素处于隐藏的情况下"></a>v-if：当dom元素的切换不频繁，可以使用。特别是，首次元素处于隐藏的情况下</h5><hr><h2 id="2、说说对SPA单页面的理解，他的优缺点分别是什么？"><a href="#2、说说对SPA单页面的理解，他的优缺点分别是什么？" class="headerlink" title="2、说说对SPA单页面的理解，他的优缺点分别是什么？"></a>2、说说对SPA单页面的理解，他的优缺点分别是什么？</h2><h3 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h3><p>SPA的英文是 single-page application，也就是说整个项目中只有一个页面。</p><p>单页面应用的实现思路： 就是Web页面初始化时加载所有的HTML、JavaScript和 CSS，内容的变化，靠动态操作DOM。</p><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><h6 id="1）：局部刷新。—用户体验好、快，内容的改变不需要重新加载整个页面。"><a href="#1）：局部刷新。—用户体验好、快，内容的改变不需要重新加载整个页面。" class="headerlink" title="1）：局部刷新。—用户体验好、快，内容的改变不需要重新加载整个页面。"></a>1）：局部刷新。—用户体验好、快，内容的改变不需要重新加载整个页面。</h6><h6 id="2）：服务器的压力小。-—-基于上面一点，SPA对服务器压力小；"><a href="#2）：服务器的压力小。-—-基于上面一点，SPA对服务器压力小；" class="headerlink" title="2）：服务器的压力小。  — 基于上面一点，SPA对服务器压力小；"></a>2）：服务器的压力小。  — 基于上面一点，SPA对服务器压力小；</h6><h6 id="3）：前后端职责分离。-—-架构清晰，前端进行交互逻辑，后端负责数据处理；"><a href="#3）：前后端职责分离。-—-架构清晰，前端进行交互逻辑，后端负责数据处理；" class="headerlink" title="3）：前后端职责分离。 — 架构清晰，前端进行交互逻辑，后端负责数据处理；"></a>3）：前后端职责分离。 — 架构清晰，前端进行交互逻辑，后端负责数据处理；</h6><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><h6 id="1）：初次加载耗时多。—-为实现单页面Web应用功能及显示效果，需要在加载页面的时候将，JavaScript、CSS统一加载，部分页面按需加载；"><a href="#1）：初次加载耗时多。—-为实现单页面Web应用功能及显示效果，需要在加载页面的时候将，JavaScript、CSS统一加载，部分页面按需加载；" class="headerlink" title="1）：初次加载耗时多。— 为实现单页面Web应用功能及显示效果，需要在加载页面的时候将，JavaScript、CSS统一加载，部分页面按需加载；"></a>1）：初次加载耗时多。— 为实现单页面Web应用功能及显示效果，需要在加载页面的时候将，JavaScript、CSS统一加载，部分页面按需加载；</h6><h6 id="2）：前进后退路由管理问题。-—-由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退的功能，所有的页面切换需要自己搭建堆栈管理（vue-router完成）"><a href="#2）：前进后退路由管理问题。-—-由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退的功能，所有的页面切换需要自己搭建堆栈管理（vue-router完成）" class="headerlink" title="2）：前进后退路由管理问题。 — 由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退的功能，所有的页面切换需要自己搭建堆栈管理（vue-router完成）"></a>2）：前进后退路由管理问题。 — 由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退的功能，所有的页面切换需要自己搭建堆栈管理（vue-router完成）</h6><h6 id="3）：SEO难度较大。—-由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。"><a href="#3）：SEO难度较大。—-由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。" class="headerlink" title="3）：SEO难度较大。— 由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。"></a>3）：SEO难度较大。— 由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势。</h6><hr><h2 id="3、怎么理解Vue的单向数据流"><a href="#3、怎么理解Vue的单向数据流" class="headerlink" title="3、怎么理解Vue的单向数据流"></a>3、怎么理解Vue的单向数据流</h2><h4 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h4><h5 id="单项数据流是发生在-父组件向子组件传值的时候-，所有的prop使得起父子prop之间形成了一个单向下行绑定。"><a href="#单项数据流是发生在-父组件向子组件传值的时候-，所有的prop使得起父子prop之间形成了一个单向下行绑定。" class="headerlink" title="单项数据流是发生在   父组件向子组件传值的时候  ，所有的prop使得起父子prop之间形成了一个单向下行绑定。"></a>单项数据流是发生在   <em><strong>父组件向子组件传值的时候</strong></em>  ，所有的prop使得起父子prop之间形成了一个单向下行绑定。</h5><h5 id="也就是说：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态。"><a href="#也就是说：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态。" class="headerlink" title="也就是说：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态。"></a>也就是说：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态。</h5><h4 id="而且"><a href="#而且" class="headerlink" title="而且"></a>而且</h4><h5 id="每次父组件发生更新时，子组件中所有的prop都会刷新为最新的值。所以，在一个子组件内部改变prop，Vue会在浏览器的控制台发出警告。"><a href="#每次父组件发生更新时，子组件中所有的prop都会刷新为最新的值。所以，在一个子组件内部改变prop，Vue会在浏览器的控制台发出警告。" class="headerlink" title="每次父组件发生更新时，子组件中所有的prop都会刷新为最新的值。所以，在一个子组件内部改变prop，Vue会在浏览器的控制台发出警告。"></a>每次父组件发生更新时，子组件中所有的prop都会刷新为最新的值。所以，在一个子组件内部改变prop，Vue会在浏览器的控制台发出警告。</h5><hr><h2 id="4、computed和watch的区别和运用的场景？"><a href="#4、computed和watch的区别和运用的场景？" class="headerlink" title="4、computed和watch的区别和运用的场景？"></a>4、computed和watch的区别和运用的场景？</h2><h3 id="首先（相同点）："><a href="#首先（相同点）：" class="headerlink" title="首先（相同点）："></a>首先（相同点）：</h3><h6 id="computed-和-watch都可以实现数据的监听。"><a href="#computed-和-watch都可以实现数据的监听。" class="headerlink" title="computed 和 watch都可以实现数据的监听。"></a>computed 和 watch都可以实现数据的监听。</h6><h3 id="其次（区别）："><a href="#其次（区别）：" class="headerlink" title="其次（区别）："></a>其次（区别）：</h3><h5 id="第一（本质）："><a href="#第一（本质）：" class="headerlink" title="第一（本质）："></a>第一（本质）：</h5><p><strong>computed：是计算属性</strong>，依赖其他属性值，并且computed的值<strong>有缓存</strong>，当依赖的属性值发生改变时，才会重新计算computed的值，它可以设置getter和setter。</p><p><strong>watch：</strong>更多的是<strong>观察</strong>的作用，每当监听的数据变化都会执行回调进行后续操作，他只能设置getter.</p><h5 id="第二（运用场景）："><a href="#第二（运用场景）：" class="headerlink" title="第二（运用场景）："></a>第二（运用场景）：</h5><p><strong>computed：</strong>当我们需要进行数值计算，并且依赖于其他数据时，使用computed。</p><p><strong>watch：</strong>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch。</p><hr><h2 id="5、直接用下标（索引）给一个数组项赋值，Vue能检测到变化吗？"><a href="#5、直接用下标（索引）给一个数组项赋值，Vue能检测到变化吗？" class="headerlink" title="5、直接用下标（索引）给一个数组项赋值，Vue能检测到变化吗？"></a>5、直接用下标（索引）给一个数组项赋值，Vue能检测到变化吗？</h2><h3 id="不能。"><a href="#不能。" class="headerlink" title="不能。"></a>不能。</h3><h5 id="因为，vue在做数据劫持时，只对数组做了劫持，没有对数组的每一项进行劫持。所以用下标的方式修改数组时，vue不能检测到数据的变化。"><a href="#因为，vue在做数据劫持时，只对数组做了劫持，没有对数组的每一项进行劫持。所以用下标的方式修改数组时，vue不能检测到数据的变化。" class="headerlink" title="因为，vue在做数据劫持时，只对数组做了劫持，没有对数组的每一项进行劫持。所以用下标的方式修改数组时，vue不能检测到数据的变化。"></a>因为，vue在做数据劫持时，只对数组做了劫持，没有对数组的每一项进行劫持。所以用下标的方式修改数组时，vue不能检测到数据的变化。</h5><h5 id="为了解决他们，Vue也提供了操作方法：Vue-set"><a href="#为了解决他们，Vue也提供了操作方法：Vue-set" class="headerlink" title="为了解决他们，Vue也提供了操作方法：Vue.set"></a>为了解决他们，Vue也提供了操作方法：Vue.set</h5><h5 id="Vue-set（数组名，下标，新值）"><a href="#Vue-set（数组名，下标，新值）" class="headerlink" title="Vue.set（数组名，下标，新值）"></a>Vue.set（数组名，下标，新值）</h5><hr><h1 id="6、谈谈对Vue生命周期的理解？"><a href="#6、谈谈对Vue生命周期的理解？" class="headerlink" title="6、谈谈对Vue生命周期的理解？"></a>6、谈谈对Vue生命周期的理解？</h1><h3 id="1）、生命周期是什么？"><a href="#1）、生命周期是什么？" class="headerlink" title="1）、生命周期是什么？"></a>1）、生命周期是什么？</h3><h6 id="Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载DOM–-gt-渲染、更新—-gt-渲染、卸载等一系列过程，我们称这是Vue生命周期。"><a href="#Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载DOM–-gt-渲染、更新—-gt-渲染、卸载等一系列过程，我们称这是Vue生命周期。" class="headerlink" title="Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载DOM–>渲染、更新—>渲染、卸载等一系列过程，我们称这是Vue生命周期。"></a>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载DOM–&gt;渲染、更新—&gt;渲染、卸载等一系列过程，我们称这是Vue生命周期。</h6><h3 id="2）、各个生命周期阶段及其钩子函数"><a href="#2）、各个生命周期阶段及其钩子函数" class="headerlink" title="2）、各个生命周期阶段及其钩子函数"></a>2）、各个生命周期阶段及其钩子函数</h3><h5 id="Vue的生命周期核心经历了四个阶段，在四个阶段的前后分别由两个钩子函数。"><a href="#Vue的生命周期核心经历了四个阶段，在四个阶段的前后分别由两个钩子函数。" class="headerlink" title="Vue的生命周期核心经历了四个阶段，在四个阶段的前后分别由两个钩子函数。"></a>Vue的生命周期核心经历了四个阶段，在四个阶段的前后分别由两个钩子函数。</h5><h6 id="第一阶段：-数据挂载阶段：把配置项data中的属性，赋给了vue对象本身，并且做了数据劫持。"><a href="#第一阶段：-数据挂载阶段：把配置项data中的属性，赋给了vue对象本身，并且做了数据劫持。" class="headerlink" title="第一阶段： 数据挂载阶段：把配置项data中的属性，赋给了vue对象本身，并且做了数据劫持。"></a>第一阶段： 数据挂载阶段：把配置项data中的属性，赋给了vue对象本身，并且做了数据劫持。</h6><p>该阶段前后的两个钩子函数： beforeCreate 和  created</p><h6 id="第二阶段：模板渲染阶段：把vue对象的数据渲染到模板上。"><a href="#第二阶段：模板渲染阶段：把vue对象的数据渲染到模板上。" class="headerlink" title="第二阶段：模板渲染阶段：把vue对象的数据渲染到模板上。"></a>第二阶段：模板渲染阶段：把vue对象的数据渲染到模板上。</h6><p>该阶段前后的两个钩子函数：beforeMount 和  mounted</p><h6 id="第三阶段：组件更新阶段：当数据发送变化时，组件会进行重新渲染，所以，准确的说是，组件重新渲染阶段"><a href="#第三阶段：组件更新阶段：当数据发送变化时，组件会进行重新渲染，所以，准确的说是，组件重新渲染阶段" class="headerlink" title="第三阶段：组件更新阶段：当数据发送变化时，组件会进行重新渲染，所以，准确的说是，组件重新渲染阶段"></a>第三阶段：组件更新阶段：当数据发送变化时，组件会进行重新渲染，所以，准确的说是，组件重新渲染阶段</h6><p>该阶段前后的两个钩子函数：beforeUpdate 和 updated</p><h6 id="第四阶段：组件销毁阶段：组件销毁。"><a href="#第四阶段：组件销毁阶段：组件销毁。" class="headerlink" title="第四阶段：组件销毁阶段：组件销毁。"></a>第四阶段：组件销毁阶段：组件销毁。</h6><p>该阶段前后的两个钩子函数：beforeDestroy 和 destroyed</p><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><h6 id="当使用keep-alive包裹组件时，会有组件激活和停用之说，这两个钩子函数分别是：activited-和-deactivated"><a href="#当使用keep-alive包裹组件时，会有组件激活和停用之说，这两个钩子函数分别是：activited-和-deactivated" class="headerlink" title="当使用keep-alive包裹组件时，会有组件激活和停用之说，这两个钩子函数分别是：activited  和  deactivated"></a>当使用keep-alive包裹组件时，会有组件激活和停用之说，这两个钩子函数分别是：activited  和  deactivated</h6><hr><h1 id="Vue生命周期详解"><a href="#Vue生命周期详解" class="headerlink" title="Vue生命周期详解"></a>Vue生命周期详解</h1><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/202104231514186151.png"></p><h4 id="使用Vue框架，需要再合适的时机做合适的事情，了解了Vue对象的生命周期和钩子函数，才能知道，哪些事情应该在哪个函数里做。"><a href="#使用Vue框架，需要再合适的时机做合适的事情，了解了Vue对象的生命周期和钩子函数，才能知道，哪些事情应该在哪个函数里做。" class="headerlink" title="使用Vue框架，需要再合适的时机做合适的事情，了解了Vue对象的生命周期和钩子函数，才能知道，哪些事情应该在哪个函数里做。"></a>使用Vue框架，需要再合适的时机做合适的事情，了解了Vue对象的生命周期和钩子函数，才能知道，哪些事情应该在哪个函数里做。</h4><h5 id="一、vue生命周期的理解"><a href="#一、vue生命周期的理解" class="headerlink" title="一、vue生命周期的理解"></a>一、vue生命周期的理解</h5><p>1、生命周期</p><p>用人举例：生命周期就是一个人的一生，从人的出生，到成长，到工作，到死亡，就是人的一生，也叫一个人的生命周期。</p><p>2、对象的生命周期</p><p>在程序开发中对象的生命周期就是：从对象的创建，到使用对象，到对象的消亡整个过程。</p><p>3、Vue的生命周期</p><p>Vue实例，Vue组件实例都是Vue对象，也是对象。所以，Vue的生命周期和对象的生命周期是同样的道理。</p><h5 id="二、Vue生命周期经历的阶段"><a href="#二、Vue生命周期经历的阶段" class="headerlink" title="二、Vue生命周期经历的阶段"></a>二、Vue生命周期经历的阶段</h5><p>Vue对象的生命周期也分不同的阶段，不同的阶段也可以做不同的事情，但是不同的vue（组件）对象在不同的阶段做的事情也不尽相同，所以，每个vue组件的代码不相同。</p><h6 id="Vue生命周期经历哪些阶段："><a href="#Vue生命周期经历哪些阶段：" class="headerlink" title="Vue生命周期经历哪些阶段："></a>Vue生命周期经历哪些阶段：</h6><p>1、总体来说：初始化、运行中、销毁</p><p>2、详细来说：开始创建、初始化数据、编译模板、挂载Dom、渲染–&gt;更新–&gt;渲染、销毁等一系列过程</p><h5 id="三、生命周期经历的阶段和钩子函数"><a href="#三、生命周期经历的阶段和钩子函数" class="headerlink" title="三、生命周期经历的阶段和钩子函数"></a>三、生命周期经历的阶段和钩子函数</h5><h6 id="1、实例化Vue（组件）对象：new-Vue"><a href="#1、实例化Vue（组件）对象：new-Vue" class="headerlink" title="1、实例化Vue（组件）对象：new   Vue()"></a>1、实例化Vue（组件）对象：new   Vue()</h6><h6 id="2、初始化事件和生命周期-init-events-和-init-cycle"><a href="#2、初始化事件和生命周期-init-events-和-init-cycle" class="headerlink" title="2、初始化事件和生命周期  init  events  和  init cycle"></a>2、初始化事件和生命周期  init  events  和  init cycle</h6><h6 id="3、beforeCreated函数："><a href="#3、beforeCreated函数：" class="headerlink" title="3、beforeCreated函数："></a>3、beforeCreated函数：</h6><p>在实例初始化之后，数据观测（data observer）和 event/watcher 事件配置之前被调用。</p><p>此时Vue（组件）对象被创建，但是Vue对象的属性还没有绑定，如果data属性，computed属性还没有绑定，即没有值。</p><p>此时还没有数据和真实DOM。即：属性还没有赋值，也没有动态创建template属性对应的HTML元素（二阶段的createUI海曙还没有执行）</p><h6 id="4、挂载数据（属性赋值）"><a href="#4、挂载数据（属性赋值）" class="headerlink" title="4、挂载数据（属性赋值）"></a>4、挂载数据（属性赋值）</h6><p>包括属性和computed的运算。</p><h6 id="5、Created函数："><a href="#5、Created函数：" class="headerlink" title="5、Created函数："></a>5、Created函数：</h6><p>Vue对象的属性有值了，但是DOM还没有生成，$el属性还不存在。此时有数据了，但是还没有真实DOM</p><p>即：data，computed都执了。属性已经赋值，但还没有动态创建template属性对应的HTML元素，所以，此时如果更改数据不会触发updated函数。</p><p>如果数据初始值就来自于后端，可以发送ajax。或者fetch请求数据。</p><h6 id="6、检查"><a href="#6、检查" class="headerlink" title="6、检查"></a>6、检查</h6><p>1）、检查是否有el属性</p><p>检查Vue配置，即new Vue()里面的el项是否存在，有就继续检查template项。没有则等到手动绑定调用 vm.$mount() </p><p>完成了全局变量$el的绑定。</p><p>2）、检查是否有template属性</p><p>检查配置中的template项，如果没有template进行填充被绑定区域，则被绑定区域的el对象的outerHtml（即整个#app DOM对象，包括 div id=”app”和div标签）都作为被填充对象替换掉填充区域</p><p>即：如果vue对象中有 template属性，那么，template后面的HTML会替换$el对应的内容。如果有render属性，那么render就会替换template。</p><p>即：优先关系时： render &gt; template &gt; el</p><h6 id="7、beforeMount函数："><a href="#7、beforeMount函数：" class="headerlink" title="7、beforeMount函数："></a>7、beforeMount函数：</h6><p>模板编译（template）数据挂载（把数据显示载模板里）之前执行的钩子函数。</p><p>此时this.$el有值但是数据还没挂载到页面上。即此时页面中的里的变量还没有被数据替换</p><h6 id="8、模板编译："><a href="#8、模板编译：" class="headerlink" title="8、模板编译："></a>8、模板编译：</h6><p>用Vue对象的数据（属性）替换模板中的内容</p><h6 id="9、Mounted函数："><a href="#9、Mounted函数：" class="headerlink" title="9、Mounted函数："></a>9、Mounted函数：</h6><p>模板编译完成，数据挂载完成</p><p>即：此时已经把数据挂载到了页面上，所以，页面上能够看到正确的数据了。</p><p>此处虽然也可以发送异步请求，但是没有created早，所以会显得比较缓慢，所以建议在 creatd里发送请求。</p><h6 id="10、beforeUpdated函数："><a href="#10、beforeUpdated函数：" class="headerlink" title="10、beforeUpdated函数："></a>10、beforeUpdated函数：</h6><p>组件更新之前执行的函数只有数据更新后，才能调用beforeUpdate，注意：此数据一定是在模板上出现的数据，并且改数据值修改前后不一样。否则，不会，也没有必要触发组件更新（因为数据不出现在模板里数据也灭有改变，就没有必要再次渲染）数据更新了，但是Vue（组件）对象对应的DOM中的内部（innerHTML）没有变，所以叫做组件更新前</p><h6 id="11、update函数："><a href="#11、update函数：" class="headerlink" title="11、update函数："></a>11、update函数：</h6><p>组件更新之后执行的函数</p><p>Vue（组件）对象对应的dom中的内部（innerHTML）改变了，所以叫做组更新之后</p><h6 id="12、activated函数："><a href="#12、activated函数：" class="headerlink" title="12、activated函数："></a>12、activated函数：</h6><p>keep-alive组件激活时调用</p><h6 id="13、deactivated函数："><a href="#13、deactivated函数：" class="headerlink" title="13、deactivated函数："></a>13、deactivated函数：</h6><p>keep-alive组件停用时调用</p><h6 id="14、beforeDestory："><a href="#14、beforeDestory：" class="headerlink" title="14、beforeDestory："></a>14、beforeDestory：</h6><p>Vue（组件）对象销毁之前。</p><p>在这个生命周期钩子函数里，可以销毁定时器，因为定时器时全局的，属于window对象的，所以，组件销毁时，并不会销毁定时器</p><h6 id="15、destroyed："><a href="#15、destroyed：" class="headerlink" title="15、destroyed："></a>15、destroyed：</h6><p>Vue组件销毁后</p><h5 id="四、测试代码："><a href="#四、测试代码：" class="headerlink" title="四、测试代码："></a>四、测试代码：</h5><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;  &lt;title&gt;vue生命周期学习&lt;/title&gt;  &lt;/head&gt;&lt;body&gt;  &lt;div id="app"&gt;    &lt;h1&gt;{{message}}&lt;/h1&gt;    &lt;h1&gt;count:{{count}}&lt;/h1&gt;  &lt;/div&gt;  &lt;input id="btn01" type="button" value="测试" /&gt;&lt;/body&gt;&lt;script type="text/javascript" src="js/vue.min.js" &gt;&lt;/script&gt;&lt;script&gt;  var vm = new Vue({    el: '#app',    data: {      message: 'Vue的生命周期',      age:2    },    computed:{    count:function(){    return this.age+1;    }    },//  template:"&lt;p&gt;vue对象中的template的内容&lt;/p&gt;",//  render: function(createElement) {//      return createElement('h1', 'this is createElement')//  },    beforeCreate: function() {      console.group('------beforeCreate创建前状态------');      console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined      console.log("%c%s", "color:red","data   : " + this.$data); //undefined      console.log("%c%s", "color:red","count   : " + this.count); //undefined       console.log("%c%s", "color:red","message: " + this.message)     },    created: function() {      console.group('------created创建完毕状态------');      console.log("%c%s", "color:red","el     : " + this.$el); //undefined      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化       console.log("%c%s", "color:red","count   : " + this.count); //undefined       console.log("%c%s", "color:red","message: " + this.message); //已被初始化    },    //完成了el的绑定    beforeMount: function() {       console.group('------beforeMount挂载前状态------');       console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化       console.log(this.$el.innerHTML);           console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化         console.log("%c%s", "color:red","message: " + this.message); //已被初始化      },    mounted: function() {      console.group('------mounted 挂载结束状态------');      console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化      console.log(this.$el);          console.log(this.$el.innerHTML);          console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化      console.log("%c%s", "color:red","message: " + this.message); //已被初始化     },    beforeUpdate: function () {      console.group('beforeUpdate 更新前状态===============》');      console.log("%c%s", "color:red","el     : " + this.$el);      console.log(this.$el.innerHTML);      console.log("%c%s", "color:red","data   : " + this.$data.message);       console.log("%c%s", "color:red","message: " + this.message);     }    ,    updated: function () {      console.group('updated 更新完成状态===============》');      console.log("%c%s", "color:red","el     : " + this.$el);      console.log(this.$el.innerHTML);         console.log("%c%s", "color:red","data   : " + this.$data);       console.log("%c%s", "color:red","message: " + this.message);     },//  beforeDestroy: function () {//    console.group('beforeDestroy 销毁前状态===============》');//    console.log("%c%s", "color:red","el     : " + this.$el);//    console.log(this.$el);    //    console.log("%c%s", "color:red","data   : " + this.$data); //    console.log("%c%s", "color:red","message: " + this.message); //  },//  destroyed: function () {//    console.group('destroyed 销毁完成状态===============》');//    console.log("%c%s", "color:red","el     : " + this.$el);//    console.log(this.$el);  //    console.log("%c%s", "color:red","data   : " + this.$data); //    console.log("%c%s", "color:red","message: " + this.message)//  }  });    document.getElementById("btn01").onclick = function(){  vm.message="改了";  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="五、模拟Vue的构造函数（部分代码）"><a href="#五、模拟Vue的构造函数（部分代码）" class="headerlink" title="五、模拟Vue的构造函数（部分代码）"></a>五、模拟Vue的构造函数（部分代码）</h5><p>myVue.js</p><pre class="line-numbers language-none"><code class="language-none">class MyVue{constructor(obj){//默认值let defaultObj={  data: null,  computed:null,  watch:null,  beforeCreate:function(){  },  created:function(){  },  beforeMount:function(){  },  mounted:function(){  }}for(let key in defaultObj){obj[key]?this[key]=obj[key]:this[key]=defaultObj[key];}//对象创建完毕已经有this了。this.beforeCreate();//挂载数据：//1）、把传入的data属性的值赋给thisif(obj.data){for(let key in this.data){this[key] = obj.data[key];}this.$data = obj.data;//设置全局变量}//2）、计算属性if(obj.computed){for(let key in obj.computed){this[key] = obj.computed[key].call(this);}}//created函数this.created();//检查是否有el属性if(obj.el){this.el = $(obj.el);this.$el = $(obj.el);//设置全局变量}//检查是否有template属性if(this.template){//this.template = obj.template;//动态创建template 里所有的html元素}//beforeMonutethis.beforeMount();//用vue对象的数据（属性）替换模板中的内容//1)、替换data中的数据let html = this.el.innerHTML;for(let key in this.data){//用属性值替换，属性名（页面上用双花括号包起来的）html=html.replace(new RegExp("{{"+key+"}}","g"),this[key]);}//2)、替换computed中的数据for(let key in this.computed){//用属性值替换，属性名（页面上用双花括号包起来的）html=html.replace(new RegExp("{{"+key+"}}","g"),this[key]);}this.el.innerHTML = html;//mounted函数：this.mounted();}addWatch(){}//数据双向绑定//} function $(str){//#box .cls  pif(str.charAt(0)=="#"){return document.getElementById(str.substring(1));}else if(str.charAt(0)=="."){return document.getElementsByClassName(str.substring(1));}else{return document.getElementsByTagName(str);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>html代码：</p><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;  &lt;div id="app"&gt;    &lt;h1&gt;{{message}}&lt;/h1&gt;    &lt;h1&gt;count:{{count}}&lt;/h1&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript" src="js/myvue.js" &gt;&lt;/script&gt;&lt;script&gt;  var vm = new MyVue({    el: '#app',    data: {      message: 'Vue的生命周期',      age:1    },    computed:{        count:function(){           return this.age+1;        }    },    beforeCreate: function() {      console.group('------beforeCreate创建前状态------');      console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined      console.log("%c%s", "color:red","data   : " + this.$data); //undefined      console.log("%c%s", "color:red","message: " + this.message)    },    created: function() {      console.group('------created创建完毕状态------');      console.log("%c%s", "color:red","el     : " + this.$el); //undefined      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化      console.log("%c%s", "color:red","message: " + this.message); //已被初始化    },    //完成了el的绑定    beforeMount: function() {       console.group('------beforeMount挂载前状态------');       console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化       console.log(this.$el);       console.log(this.$el.innerHTML);          console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化        console.log("%c%s", "color:red","message: " + this.message); //已被初始化     },    mounted: function() {      console.group('------mounted 挂载结束状态------');      console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化      console.log(this.$el);         console.log(this.$el.innerHTML);         console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化      console.log("%c%s", "color:red","message: " + this.message); //已被初始化    }     })<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="7、Vue的父组件和子组件生命周期钩子函数执行顺序？"><a href="#7、Vue的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="7、Vue的父组件和子组件生命周期钩子函数执行顺序？"></a>7、Vue的父组件和子组件生命周期钩子函数执行顺序？</h2><h3 id="Vue的父子组件钩子函数的执行顺序可以归类为4个部分："><a href="#Vue的父子组件钩子函数的执行顺序可以归类为4个部分：" class="headerlink" title="Vue的父子组件钩子函数的执行顺序可以归类为4个部分："></a>Vue的父子组件钩子函数的执行顺序可以归类为4个部分：</h3><h5 id="第一部分：首次加载渲染"><a href="#第一部分：首次加载渲染" class="headerlink" title="第一部分：首次加载渲染"></a>第一部分：首次加载渲染</h5><h6 id="父-beforeCreated-gt-父-created-gt-父-beforeMount-gt-子-beforeCreate-gt-子-created-gt-子-beforeMount-gt-子-mounted-gt-父-mounted"><a href="#父-beforeCreated-gt-父-created-gt-父-beforeMount-gt-子-beforeCreate-gt-子-created-gt-子-beforeMount-gt-子-mounted-gt-父-mounted" class="headerlink" title="父 beforeCreated->父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted"></a>父 beforeCreated-&gt;父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</h6><h5 id="第二部分：父组件修改子组件的props值时："><a href="#第二部分：父组件修改子组件的props值时：" class="headerlink" title="第二部分：父组件修改子组件的props值时："></a>第二部分：父组件修改子组件的props值时：</h5><h6 id="父-beforeUpdate-gt-子-beforeUpdate-gt-子-updated-gt-父-updated"><a href="#父-beforeUpdate-gt-子-beforeUpdate-gt-子-updated-gt-父-updated" class="headerlink" title="父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated"></a>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</h6><h5 id="第三部分：父组件修改的数据跟子组件没有关系时："><a href="#第三部分：父组件修改的数据跟子组件没有关系时：" class="headerlink" title="第三部分：父组件修改的数据跟子组件没有关系时："></a>第三部分：父组件修改的数据跟子组件没有关系时：</h5><h6 id="不会影响子组件-父-beforeUpdate-gt-父-updated"><a href="#不会影响子组件-父-beforeUpdate-gt-父-updated" class="headerlink" title="不会影响子组件 父 beforeUpdate -> 父 updated"></a>不会影响子组件 父 beforeUpdate -&gt; 父 updated</h6><h5 id="第四部分：销毁过程"><a href="#第四部分：销毁过程" class="headerlink" title="第四部分：销毁过程"></a>第四部分：销毁过程</h5><h6 id="父-beforeDestroy-gt-子-beforeDestroy-gt-子-destroyed-gt-父-destroyed"><a href="#父-beforeDestroy-gt-子-beforeDestroy-gt-子-destroyed-gt-父-destroyed" class="headerlink" title="父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed"></a>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</h6><hr><h2 id="8、在那个生命周期内调用异步请求？"><a href="#8、在那个生命周期内调用异步请求？" class="headerlink" title="8、在那个生命周期内调用异步请求？"></a>8、在那个生命周期内调用异步请求？</h2><h5 id="答：大部分时候，会在created发送请求。"><a href="#答：大部分时候，会在created发送请求。" class="headerlink" title="答：大部分时候，会在created发送请求。"></a>答：大部分时候，会在created发送请求。</h5><h6 id="1）、此时data已经挂载到Vue实例了，放在beforeCreate里太早，Vue实例没有数据，放在mounted里太晚"><a href="#1）、此时data已经挂载到Vue实例了，放在beforeCreate里太早，Vue实例没有数据，放在mounted里太晚" class="headerlink" title="1）、此时data已经挂载到Vue实例了，放在beforeCreate里太早，Vue实例没有数据，放在mounted里太晚"></a>1）、此时data已经挂载到Vue实例了，放在beforeCreate里太早，Vue实例没有数据，放在mounted里太晚</h6><h6 id="2）、放在-created-中有助于一致性，因为ssr不支持-beforeMount-、mounted-钩子函数。"><a href="#2）、放在-created-中有助于一致性，因为ssr不支持-beforeMount-、mounted-钩子函数。" class="headerlink" title="2）、放在 created 中有助于一致性，因为ssr不支持 beforeMount 、mounted 钩子函数。"></a>2）、放在 created 中有助于一致性，因为ssr不支持 beforeMount 、mounted 钩子函数。</h6><p>Created的使用场景：如果组件的初始数据来自于后端，那就在created里发送请求</p><hr><h2 id="9、组件中data为什么是一个函数？"><a href="#9、组件中data为什么是一个函数？" class="headerlink" title="9、组件中data为什么是一个函数？"></a>9、组件中data为什么是一个函数？</h2><h6 id="答：-data时引用类型，如果不是函数，所有组件的data会指向同一块内存区域，导致数据之间互相影响。而使用函数时，每次实例化组件值，调用函数，return一个新的（new）的data对象。这样每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性不会互相影响。"><a href="#答：-data时引用类型，如果不是函数，所有组件的data会指向同一块内存区域，导致数据之间互相影响。而使用函数时，每次实例化组件值，调用函数，return一个新的（new）的data对象。这样每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性不会互相影响。" class="headerlink" title="答： data时引用类型，如果不是函数，所有组件的data会指向同一块内存区域，导致数据之间互相影响。而使用函数时，每次实例化组件值，调用函数，return一个新的（new）的data对象。这样每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性不会互相影响。"></a>答： data时引用类型，如果不是函数，所有组件的data会指向同一块内存区域，导致数据之间互相影响。而使用函数时，每次实例化组件值，调用函数，return一个新的（new）的data对象。这样每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性不会互相影响。</h6><hr><h2 id="10、v-model的原理？"><a href="#10、v-model的原理？" class="headerlink" title="10、v-model的原理？"></a>10、v-model的原理？</h2><h6 id="v-model指令主要用在表单元素上实现数据双向绑定的。"><a href="#v-model指令主要用在表单元素上实现数据双向绑定的。" class="headerlink" title="v-model指令主要用在表单元素上实现数据双向绑定的。"></a>v-model指令主要用在表单元素上实现数据双向绑定的。</h6><h6 id="例如：input、textarea、select等创建双向数据绑定，本质上不过是语法糖，其实v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件："><a href="#例如：input、textarea、select等创建双向数据绑定，本质上不过是语法糖，其实v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：" class="headerlink" title="例如：input、textarea、select等创建双向数据绑定，本质上不过是语法糖，其实v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件："></a>例如：input、textarea、select等创建双向数据绑定，本质上不过是语法糖，其实v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</h6><ul><li>text和textarea元素使用 value 属性和 input 事件；</li><li>checkbox 和radio 使用 checked 属性和 change事件；</li><li>select 字段将value作为 prop 并将 change 作为事件。</li></ul><hr><h2 id="11、Vue实现数据绑定的原理？"><a href="#11、Vue实现数据绑定的原理？" class="headerlink" title="11、Vue实现数据绑定的原理？"></a>11、Vue实现数据绑定的原理？</h2><h4 id="Vue数据绑定是通过-数据劫持-和-观察者模式-的方式来实现的。"><a href="#Vue数据绑定是通过-数据劫持-和-观察者模式-的方式来实现的。" class="headerlink" title="Vue数据绑定是通过 数据劫持 和 观察者模式 的方式来实现的。"></a>Vue数据绑定是通过 <em>数据劫持</em> 和 <em>观察者模式</em> 的方式来实现的。</h4><h6 id="1、数据劫持：使用Object-defineProperty"><a href="#1、数据劫持：使用Object-defineProperty" class="headerlink" title="1、数据劫持：使用Object.defineProperty();"></a>1、数据劫持：使用Object.defineProperty();</h6><h6 id="目的是：感知属性的变化。当给属性赋值时，程序是能够感知的（知道的）。如果知道的话，就可以控制属性值的有效变化范围，也可以改变其他属性的值等。"><a href="#目的是：感知属性的变化。当给属性赋值时，程序是能够感知的（知道的）。如果知道的话，就可以控制属性值的有效变化范围，也可以改变其他属性的值等。" class="headerlink" title="目的是：感知属性的变化。当给属性赋值时，程序是能够感知的（知道的）。如果知道的话，就可以控制属性值的有效变化范围，也可以改变其他属性的值等。"></a>目的是：<em>感知属性的变化</em>。当给属性赋值时，程序是能够感知的（知道的）。如果知道的话，就可以控制属性值的有效变化范围，也可以改变其他属性的值等。</h6><p>  当你把一个普通的 JavaScript 对象（json）传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。</p><h6 id="2、观察者模式（发布订阅者模式）："><a href="#2、观察者模式（发布订阅者模式）：" class="headerlink" title="2、观察者模式（发布订阅者模式）："></a>2、观察者模式（发布订阅者模式）：</h6><h6 id="目的：当属性发生变化时，使用该数据地方（模板，计算属性，wath等等）跟着变化"><a href="#目的：当属性发生变化时，使用该数据地方（模板，计算属性，wath等等）跟着变化" class="headerlink" title="目的：当属性发生变化时，使用该数据地方（模板，计算属性，wath等等）跟着变化"></a>目的：当属性发生变化时，使用该数据地方（模板，计算属性，wath等等）跟着变化</h6><hr><h2 id="Object-defineProperty-函数详解"><a href="#Object-defineProperty-函数详解" class="headerlink" title="Object.defineProperty()函数详解"></a>Object.defineProperty()函数详解</h2><p>ES5新增的函数Object.defineProperty()，可以给<a href="https://so.csdn.net/so/search?q=JavaScript&amp;spm=1001.2101.3001.7020">JavaScript</a>对象增加属性。啊……，那以前的json对象不是本来就可以吗。为何还得搞出个这么复杂的函数来做这个事情。</p><h3 id="一、代码部分"><a href="#一、代码部分" class="headerlink" title="一、代码部分"></a>一、代码部分</h3><h4 id="1、回顾一下json对象增加属性"><a href="#1、回顾一下json对象增加属性" class="headerlink" title="1、回顾一下json对象增加属性"></a>1、回顾一下json对象增加属性</h4><pre class="line-numbers language-none"><code class="language-none">//定义一个对象Var person = {};//给对象增加一个属性Person.age = 12;Person.name = “张三疯”;Person.isAdult =”未成年”;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Ok，没有问题。但是：</p><p>1)、思考一个问题，age属性的值应该是有个用有效范围的（如：0-150），但是，这样增加的属性没法限制age属性的取值范围</p><p>2）、如果age属性的变化，会引起其它属性的变化，即其它属性的值会随着age的变化而变化，这样没法很好控制，而且很容易控制不好。如以上属性isAdult的值，不能直接随便赋值，而是age的值变化后，isAdult 的值会跟着变化。</p><h4 id="2、如果用Object-defineProperty-函数给对象增加属性"><a href="#2、如果用Object-defineProperty-函数给对象增加属性" class="headerlink" title="2、如果用Object.defineProperty()函数给对象增加属性"></a>2、如果用Object.defineProperty()函数给对象增加属性</h4><pre class="line-numbers language-none"><code class="language-none">Var person = {};Object.defineProperty(person ,"name",{    value:"张三疯",    writable:false//属性name不能修改});Console.log(person.name);//张三疯person.name = "隔壁老王"; //修改不成功console.log(person.name);//张三疯<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没想到吧，我们还可以让某些属性的值是只读的。</p><h4 id="3、如果用-Object-defineProperty-进行给对象增加属性，该属性的取值是可控的，而且会影响其它属性的变化。"><a href="#3、如果用-Object-defineProperty-进行给对象增加属性，该属性的取值是可控的，而且会影响其它属性的变化。" class="headerlink" title="3、如果用 Object.defineProperty()进行给对象增加属性，该属性的取值是可控的，而且会影响其它属性的变化。"></a>3、如果用 Object.defineProperty()进行给对象增加属性，该属性的取值是可控的，而且会影响其它属性的变化。</h4><p>注意：以下代码中，在对象的定义中，写的是带下划线的：_age，而在defineProperty()函数里写的属性名是不带下划线的:age，外部使用该对象的属性时，用不带下划线的：</p><pre class="line-numbers language-none"><code class="language-none"> let person = {    _age:12,    isAdult:"未成年"};Object.defineProperty(person,"age",{    get:function(){        return this._age;    },    set:function(newValue){        //此判断是限制属性的取值范围是0-150之间        if(newValue&lt;0 || newValue&gt;150){            return;        }        this._age = newValue;        //此判断是 _age属性的值影响isAdult的值。        if(this._age&gt;=18){            this.isAdult = "已成年";        }else{            this.isAdult = "未成年";        }    }}); person.age = 16; //此句话会调用 set函数。console.log(person.age);//此句话对调动get函数console.log(person.isAdult);//未成年 person.age = 25; //此句话会调用 set函数。console.log(person.age);//此句话对调动get函数console.log(person.isAdult);//已成年<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、概念："><a href="#二、概念：" class="headerlink" title="二、概念："></a>二、概念：</h3><h4 id="1、普及一个概念，JavaScript的属性有三种类型（重点看前两点）："><a href="#1、普及一个概念，JavaScript的属性有三种类型（重点看前两点）：" class="headerlink" title="1、普及一个概念，JavaScript的属性有三种类型（重点看前两点）："></a>1、普及一个概念，JavaScript的属性有三种类型（重点看前两点）：</h4><h6 id="1-、命名数据属性：拥有一个确定的值的属性。这也是最常见的属性。"><a href="#1-、命名数据属性：拥有一个确定的值的属性。这也是最常见的属性。" class="headerlink" title="1)、命名数据属性：拥有一个确定的值的属性。这也是最常见的属性。"></a>1)、命名数据属性：拥有一个确定的值的属性。这也是最常见的属性。</h6><h6 id="2）、命名访问器属性：通过getter和setter进行读取和赋值的属性（重点描述）"><a href="#2）、命名访问器属性：通过getter和setter进行读取和赋值的属性（重点描述）" class="headerlink" title="2）、命名访问器属性：通过getter和setter进行读取和赋值的属性（重点描述）"></a>2）、命名访问器属性：通过getter和setter进行读取和赋值的属性（重点描述）</h6><h6 id="3）、内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性-Prototype-，你不能直接访问这个属性，但可以通过Object-getPrototypeOf-方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性"><a href="#3）、内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性-Prototype-，你不能直接访问这个属性，但可以通过Object-getPrototypeOf-方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性" class="headerlink" title="3）、内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性[[Prototype]]，你不能直接访问这个属性，但可以通过Object.getPrototypeOf()方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性"></a>3）、内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性[[Prototype]]，你不能直接访问这个属性，但可以通过Object.getPrototypeOf()方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性</h6><h4 id="2、Object-defineProperty-的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。"><a href="#2、Object-defineProperty-的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。" class="headerlink" title="2、Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。"></a>2、<strong>Object.defineProperty()的作用</strong>就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性。</h4><h4 id="3、、Object-defineProperty-函数的格式："><a href="#3、、Object-defineProperty-函数的格式：" class="headerlink" title="3、、Object.defineProperty()函数的格式："></a>3、<strong>、Object.defineProperty()函数的格式：</strong></h4><h6 id="Object-defineProperty-obj-prop-desc"><a href="#Object-defineProperty-obj-prop-desc" class="headerlink" title="Object.defineProperty(obj, prop, desc)"></a>Object.defineProperty(obj, prop, desc)</h6><h6 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h6><h6 id="Obj：表示增加属性的对象"><a href="#Obj：表示增加属性的对象" class="headerlink" title="Obj：表示增加属性的对象"></a>Obj：表示增加属性的对象</h6><h6 id="Prop：属性名"><a href="#Prop：属性名" class="headerlink" title="Prop：属性名"></a>Prop：属性名</h6><h6 id="Desc：属性描述符"><a href="#Desc：属性描述符" class="headerlink" title="Desc：属性描述符"></a>Desc：属性描述符</h6><h4 id="4、属性描述符"><a href="#4、属性描述符" class="headerlink" title="4、属性描述符"></a>4、属性描述符</h4><p>1)、概念：</p><p> 属性描述符，是对当前属性的描述（包括设置）。</p><p>如 以上代码：</p><pre><code>Object.defineProperty(person ,"name",{value:"张三疯"});</code></pre><p>中的value就表示name属性的值为 “张三疯”。</p><p>2)、属性描述分为：数据描述符和存取描述符，</p><p>​    （1）、数据描述符有两个：value和writable</p><p>​    （2）、存取描述符：是由一对 getter、setter 函数功能来描述的属性</p><p>3)、共有的描述符：</p><p>数据描述符和存取描述均具有以下描述符</p><p>Configrable，enumerable</p><p>4)、属性描述符的解释</p><p>Value: 属性的取值</p><p>Writable:属性是否可以修改</p><p>configurable描述属性是否配置，以及可否删除</p><p>enumerable 描述属性是否会出现在for in 或者 Object.keys()的遍历中</p><p>get：针对命名访问器属性值的获取</p><p>Set：针对命名访问器属性值的修改</p><p>默认值：</p><table><thead><tr><th>属性名</th><th>默认值</th></tr></thead><tbody><tr><td>Value</td><td>Undefined</td></tr><tr><td>Writable</td><td>False</td></tr><tr><td>configurable</td><td>False</td></tr><tr><td>enumerable</td><td>False</td></tr><tr><td>get</td><td>Undefined</td></tr><tr><td>Set</td><td>Undefined</td></tr></tbody></table><hr><h2 id="12、Vue组件通信有哪几种方式？"><a href="#12、Vue组件通信有哪几种方式？" class="headerlink" title="12、Vue组件通信有哪几种方式？"></a>12、Vue组件通信有哪几种方式？</h2><p> Vue 组件间通信主要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式：</p><h6 id="1）、props-x2F-emit：父子组件通信"><a href="#1）、props-x2F-emit：父子组件通信" class="headerlink" title="1）、props/$emit：父子组件通信"></a>1）、props/$emit：父子组件通信</h6><h6 id="2）、ref：适用父子组件通信"><a href="#2）、ref：适用父子组件通信" class="headerlink" title="2）、ref：适用父子组件通信"></a>2）、ref：适用父子组件通信</h6><h6 id="3）、EventBus-（-emit-x2F-on）：-适用于-父子、隔代、兄弟组件通信"><a href="#3）、EventBus-（-emit-x2F-on）：-适用于-父子、隔代、兄弟组件通信" class="headerlink" title="3）、EventBus （$emit / $on）： 适用于 父子、隔代、兄弟组件通信"></a>3）、EventBus （$emit / $on）： 适用于 父子、隔代、兄弟组件通信</h6><h6 id="4）、-root：集中管理，适用于所有场景"><a href="#4）、-root：集中管理，适用于所有场景" class="headerlink" title="4）、$root：集中管理，适用于所有场景**"></a>4）、$root：集中管理，适用于所有场景**</h6><h6 id="5）、Vuex-适用于所有场景"><a href="#5）、Vuex-适用于所有场景" class="headerlink" title="5）、Vuex 适用于所有场景**"></a>5）、Vuex 适用于所有场景**</h6><hr><h2 id="13、谈谈你对-keep-alive-的了解？"><a href="#13、谈谈你对-keep-alive-的了解？" class="headerlink" title="13、谈谈你对 keep-alive 的了解？"></a>13、谈谈你对 keep-alive 的了解？</h2><p>keep-alive 可以缓存组件及其的组件的状态（数据），避免了组件的频繁创建和销毁所带来的性能损耗。</p><p>它有三个特性：</p><h6 id="1）、用于缓存组件，一般结合路由和动态组件一起使用。"><a href="#1）、用于缓存组件，一般结合路由和动态组件一起使用。" class="headerlink" title="1）、用于缓存组件，一般结合路由和动态组件一起使用。"></a>1）、用于缓存组件，一般结合路由和动态组件一起使用。</h6><h6 id="2）、提供-include-和-exclude-属性。两者都支持字符串或正则表达式，-include-表示只有名称匹配的组件会被缓存，exclude-表示任何名称匹配的组件都不会被缓存-，其中-exclude-的优先级比-include-高；"><a href="#2）、提供-include-和-exclude-属性。两者都支持字符串或正则表达式，-include-表示只有名称匹配的组件会被缓存，exclude-表示任何名称匹配的组件都不会被缓存-，其中-exclude-的优先级比-include-高；" class="headerlink" title="2）、提供 include 和 exclude 属性。两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；"></a>2）、提供 include 和 exclude 属性。两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</h6><h6 id="3）、对应两个钩子函数-activated-和-deactivated-，当组件被激活时，触发钩子函数-activated，当组件被移除时，触发钩子函数-deactivated。"><a href="#3）、对应两个钩子函数-activated-和-deactivated-，当组件被激活时，触发钩子函数-activated，当组件被移除时，触发钩子函数-deactivated。" class="headerlink" title="3）、对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。"></a>3）、对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</h6><hr><h2 id="14、Vue-中的-key-有什么作用？"><a href="#14、Vue-中的-key-有什么作用？" class="headerlink" title="14、Vue 中的 key 有什么作用？"></a>14、Vue 中的 key 有什么作用？</h2><p><strong>首先</strong></p><p> key 是Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</p><p><strong>再说一下</strong>，diff算法的执行过程：</p><p>1）、oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，<br>2）、在新节点和旧节点进行两两对比时，共有4种比较方式：<br>a.newStartIndex 和oldStartIndex 、<br>b.newEndIndex 和 oldEndIndex 、<br>c.newStartIndex 和 oldEndIndex 、<br>d.newEndIndex 和 oldStartIndex，<br>如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较。</p><hr><h2 id="15、你对Vue项目进行哪些优化？"><a href="#15、你对Vue项目进行哪些优化？" class="headerlink" title="15、你对Vue项目进行哪些优化？"></a>15、你对Vue项目进行哪些优化？</h2><h5 id="第一个方面：代码层面的优化"><a href="#第一个方面：代码层面的优化" class="headerlink" title="第一个方面：代码层面的优化"></a>第一个方面：代码层面的优化</h5><h6 id="v-if-和-v-show-区分使用场景"><a href="#v-if-和-v-show-区分使用场景" class="headerlink" title="v-if 和 v-show 区分使用场景"></a>v-if 和 v-show 区分使用场景</h6><h6 id="computed-和-watch-区分使用场景"><a href="#computed-和-watch-区分使用场景" class="headerlink" title="computed 和 watch 区分使用场景"></a>computed 和 watch 区分使用场景</h6><h6 id="v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h6><h6 id="长列表性能优化"><a href="#长列表性能优化" class="headerlink" title="长列表性能优化"></a>长列表性能优化</h6><h6 id="事件的销毁"><a href="#事件的销毁" class="headerlink" title="事件的销毁"></a>事件的销毁</h6><h6 id="图片资源懒加载"><a href="#图片资源懒加载" class="headerlink" title="图片资源懒加载"></a>图片资源懒加载</h6><h6 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h6><h6 id="第三方插件的按需引入"><a href="#第三方插件的按需引入" class="headerlink" title="第三方插件的按需引入"></a>第三方插件的按需引入</h6><h6 id="优化无限列表性能"><a href="#优化无限列表性能" class="headerlink" title="优化无限列表性能"></a>优化无限列表性能</h6><h6 id="服务端渲染-SSR-or-预渲染"><a href="#服务端渲染-SSR-or-预渲染" class="headerlink" title="服务端渲染 SSR or 预渲染"></a>服务端渲染 SSR or 预渲染</h6><h5 id="第二个方面：Webpack-层面的优化"><a href="#第二个方面：Webpack-层面的优化" class="headerlink" title="第二个方面：Webpack 层面的优化"></a>第二个方面：Webpack 层面的优化</h5><h6 id="Webpack-对图片进行压缩"><a href="#Webpack-对图片进行压缩" class="headerlink" title="Webpack 对图片进行压缩"></a>Webpack 对图片进行压缩</h6><h6 id="减少-ES6-转为-ES5-的冗余代码"><a href="#减少-ES6-转为-ES5-的冗余代码" class="headerlink" title="减少 ES6 转为 ES5 的冗余代码"></a>减少 ES6 转为 ES5 的冗余代码</h6><h6 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h6><h6 id="模板预编译"><a href="#模板预编译" class="headerlink" title="模板预编译"></a>模板预编译</h6><h6 id="提取组件的-CSS"><a href="#提取组件的-CSS" class="headerlink" title="提取组件的 CSS"></a>提取组件的 CSS</h6><h6 id="优化-SourceMap"><a href="#优化-SourceMap" class="headerlink" title="优化 SourceMap"></a>优化 SourceMap</h6><h6 id="构建结果输出分析"><a href="#构建结果输出分析" class="headerlink" title="构建结果输出分析"></a>构建结果输出分析</h6><h6 id="Vue-项目的编译优化"><a href="#Vue-项目的编译优化" class="headerlink" title="Vue 项目的编译优化"></a>Vue 项目的编译优化</h6><h5 id="第三个方面：基础的-Web-技术的优化"><a href="#第三个方面：基础的-Web-技术的优化" class="headerlink" title="第三个方面：基础的 Web 技术的优化"></a>第三个方面：基础的 Web 技术的优化</h5><h6 id="开启-gzip-压缩"><a href="#开启-gzip-压缩" class="headerlink" title="开启 gzip 压缩"></a>开启 gzip 压缩</h6><h6 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h6><h6 id="CDN-的使用"><a href="#CDN-的使用" class="headerlink" title="CDN 的使用"></a>CDN 的使用</h6><h6 id="使用-Chrome-Performance-查找性能瓶颈"><a href="#使用-Chrome-Performance-查找性能瓶颈" class="headerlink" title="使用 Chrome Performance 查找性能瓶颈"></a>使用 Chrome Performance 查找性能瓶颈</h6><hr><h2 id="16、动态路由传参2种方式params与query"><a href="#16、动态路由传参2种方式params与query" class="headerlink" title="16、动态路由传参2种方式params与query"></a>16、动态路由传参2种方式params与query</h2><h4 id="一、格式的区别"><a href="#一、格式的区别" class="headerlink" title="一、格式的区别"></a>一、格式的区别</h4><h5 id="1）、params"><a href="#1）、params" class="headerlink" title="1）、params"></a>1）、params</h5><p>传</p><pre class="line-numbers language-none"><code class="language-none">//声明式：&lt;router-link :to="{name:'user',params:{id:123}}"&gt;User&lt;/router-link&gt;//编程式：$router.push({name:'user',params:{id:'123'}})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接</p><pre class="line-numbers language-none"><code class="language-none">//模板里的写法：$route.params.参数名//脚本里的写法：this.$route.params.参数名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态路由匹配也行。</p><pre class="line-numbers language-none"><code class="language-none">1）、路由配置：{ path: '/user/:id', component: User }2）、传参：//声明式 &lt;router-link to="/user/01001"&gt;用户01001的信息&lt;/router-link&gt; //编程式 $router.push("/user/01001");3）、接值：//模板里的写法： $route.params.参数名//脚本里的写法: this.$route.params.参数名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2）、query"><a href="#2）、query" class="headerlink" title="2）、query"></a>2）、query</h5><p>传：</p><pre class="line-numbers language-none"><code class="language-none">// 带查询参数，变成 /register?plan=private$router.push({ path: '/register', query: { plan: 'private' }})注意：如果提供了 path，那么params 会被忽略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接：</p><pre class="line-numbers language-none"><code class="language-none">//模板里的写法：$route.query.参数名 //脚本里的写法:this.$route.query.参数名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二、使用场景的区别："><a href="#二、使用场景的区别：" class="headerlink" title="二、使用场景的区别："></a>二、使用场景的区别：</h4><p>1、params：在传递一个参数时使用，如果参数多的话，地址上不利于阅读</p><p>2、query：在传递多个参数时使用，地址比params好阅读</p><hr><h2 id="17、Vue实例和Vue组件写法的区别？"><a href="#17、Vue实例和Vue组件写法的区别？" class="headerlink" title="17、Vue实例和Vue组件写法的区别？"></a>17、Vue实例和Vue组件写法的区别？</h2><h6 id="1、data是个函数-一个组件的data选项必须是一个函数，且要有返回Object，只有这样，每个实例（Vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据互相影响，也就是说，组件的作用域是独立的。"><a href="#1、data是个函数-一个组件的data选项必须是一个函数，且要有返回Object，只有这样，每个实例（Vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据互相影响，也就是说，组件的作用域是独立的。" class="headerlink" title="1、data是个函数 一个组件的data选项必须是一个函数，且要有返回Object，只有这样，每个实例（Vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据互相影响，也就是说，组件的作用域是独立的。"></a>1、data是个函数 一个组件的data选项必须是一个函数，且要有返回Object，只有这样，每个实例（Vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据互相影响，也就是说，组件的作用域是独立的。</h6><h6 id="2、组件模板（html）只能有一个根标签"><a href="#2、组件模板（html）只能有一个根标签" class="headerlink" title="2、组件模板（html）只能有一个根标签"></a>2、组件模板（html）只能有一个根标签</h6><h6 id="3、组件名不可和HTML官方的标签名同名"><a href="#3、组件名不可和HTML官方的标签名同名" class="headerlink" title="3、组件名不可和HTML官方的标签名同名"></a>3、组件名不可和HTML官方的标签名同名</h6><h6 id="4、组件没有el选项，只有根实例存在el"><a href="#4、组件没有el选项，只有根实例存在el" class="headerlink" title="4、组件没有el选项，只有根实例存在el"></a>4、组件没有el选项，只有根实例存在el</h6><h6 id="5、书写：组件名如果驼峰，那么使用时，用短横线链接"><a href="#5、书写：组件名如果驼峰，那么使用时，用短横线链接" class="headerlink" title="5、书写：组件名如果驼峰，那么使用时，用短横线链接"></a>5、书写：组件名如果驼峰，那么使用时，用短横线链接</h6><hr><h2 id="18、谈谈你对VueX的理解？"><a href="#18、谈谈你对VueX的理解？" class="headerlink" title="18、谈谈你对VueX的理解？"></a>18、谈谈你对VueX的理解？</h2><h4 id="1、VueX是干什么的"><a href="#1、VueX是干什么的" class="headerlink" title="1、VueX是干什么的"></a>1、VueX是干什么的</h4><h6 id="Vuex能够保存全局数据，供整个应用使用，可以在组件之间传递数据。"><a href="#Vuex能够保存全局数据，供整个应用使用，可以在组件之间传递数据。" class="headerlink" title="Vuex能够保存全局数据，供整个应用使用，可以在组件之间传递数据。"></a>Vuex能够<em>保存全局数据</em>，供整个应用使用，可以在组件之间传递数据。</h6><h6 id="Vuex保存的数据是响应式的"><a href="#Vuex保存的数据是响应式的" class="headerlink" title="Vuex保存的数据是响应式的"></a>Vuex保存的数据是<em>响应式的</em></h6><h6 id="Vuex保存的数据可以跟踪状态的变化"><a href="#Vuex保存的数据可以跟踪状态的变化" class="headerlink" title="Vuex保存的数据可以跟踪状态的变化"></a>Vuex保存的数据可以<em>跟踪状态的变化</em></h6><h4 id="2、VueX的核心概念"><a href="#2、VueX的核心概念" class="headerlink" title="2、VueX的核心概念"></a>2、VueX的核心概念</h4><h6 id="state：数据仓库，存储所有的共享数据，相当于Vue组件里的-data"><a href="#state：数据仓库，存储所有的共享数据，相当于Vue组件里的-data" class="headerlink" title="state：数据仓库，存储所有的共享数据，相当于Vue组件里的 data"></a>state：数据仓库，存储所有的共享数据，相当于Vue组件里的 data</h6><h6 id="getter：在state的基础上派生的数据，相当于Vue组件里的-computed"><a href="#getter：在state的基础上派生的数据，相当于Vue组件里的-computed" class="headerlink" title="getter：在state的基础上派生的数据，相当于Vue组件里的 computed"></a>getter：在state的基础上派生的数据，相当于Vue组件里的 computed</h6><h6 id="mutation：修改state的数据时，用mutation，这与跟踪状态有关系"><a href="#mutation：修改state的数据时，用mutation，这与跟踪状态有关系" class="headerlink" title="mutation：修改state的数据时，用mutation，这与跟踪状态有关系"></a>mutation：修改state的数据时，用mutation，这与跟踪状态有关系</h6><h6 id="action：解决mutation里只能由同步代码的问题，action里可以有异步代码"><a href="#action：解决mutation里只能由同步代码的问题，action里可以有异步代码" class="headerlink" title="action：解决mutation里只能由同步代码的问题，action里可以有异步代码"></a>action：解决mutation里只能由同步代码的问题，action里可以有异步代码</h6><h4 id="3、VueX的数据流"><a href="#3、VueX的数据流" class="headerlink" title="3、VueX的数据流"></a>3、VueX的数据流</h4><p>组件里的dispath（派发）VueX中的action里commit（提交）mutation，mutation里修改state。state被修改后，会响应式到组件上。</p><h4 id="4、辅助函数"><a href="#4、辅助函数" class="headerlink" title="4、辅助函数"></a>4、辅助函数</h4><p>现在的面试，都会问的比较多。而且在项目中大部分都会使用辅助函数来简化项目中的代码。</p><p>有了这些辅助函数后，在组件里，不用再写$store了</p><h6 id="mapState：把VueX中的state（状态）映射（合并）到组件对象的computed上。直接使用计算属性就可以拿到VueX的状态"><a href="#mapState：把VueX中的state（状态）映射（合并）到组件对象的computed上。直接使用计算属性就可以拿到VueX的状态" class="headerlink" title="mapState：把VueX中的state（状态）映射（合并）到组件对象的computed上。直接使用计算属性就可以拿到VueX的状态"></a>mapState：把VueX中的state（状态）映射（合并）到组件对象的computed上。直接使用计算属性就可以拿到VueX的状态</h6><h6 id="mapGetters：把VueX的getters映射到组件computed上。"><a href="#mapGetters：把VueX的getters映射到组件computed上。" class="headerlink" title="mapGetters：把VueX的getters映射到组件computed上。"></a>mapGetters：把VueX的getters映射到组件computed上。</h6><h6 id="mapMutations：把VueX的mutations映射到组件的methods上"><a href="#mapMutations：把VueX的mutations映射到组件的methods上" class="headerlink" title="mapMutations：把VueX的mutations映射到组件的methods上"></a>mapMutations：把VueX的mutations映射到组件的methods上</h6><h6 id="mapActions：把VueX的actions映射到组件的methods上。"><a href="#mapActions：把VueX的actions映射到组件的methods上。" class="headerlink" title="mapActions：把VueX的actions映射到组件的methods上。"></a>mapActions：把VueX的actions映射到组件的methods上。</h6><p>示例代码：</p><pre class="line-numbers language-none"><code class="language-none">//1、vueXexport default new vueX.Store({   state:{       count:10   }}) //2、组件里import { mapState } from "vuex"; export default {  name: "Store01",  data() {    return {};  },  computed:{                ...mapState(['count']), //把vuex的state映射到组件的计算属性上        a:function(){            return 250;        },    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5、modules"><a href="#5、modules" class="headerlink" title="5、modules"></a>5、modules</h4><p>当项目比较大时，所有的全局数据存放在state里，会非常混乱，怎么办？使用module，把数据分门别类的进行处理，即：<strong>模块化</strong>。 每个模块是一个独立的store。然后由总体的store引入所有的分模块store。</p><p>示例代码：</p><pre class="line-numbers language-none"><code class="language-none">//1、moduleA.js  此模块里管理的数据是 count。 export default {    namespaced:true, //这个命名空间是区分不同模块的    state:{        count:1    },    mutations:{       ……………………    },    actions:{                incCount(context){            console.log("moduleA的action");            setTimeout(()=&gt;{                context.commit("incCount");            },2000);        }    }} 2、创建vueX.store对象  import moduleA from "./moduleA"; export default new vueX.Store({    modules:{        moduleA:moduleA    }    //简写：    modules:{        moduleA,moduleB    }});  //2、组件里派发action时，加上namespaced，用来区分不同的模块 this.$store.dispatch('moduleA/incCount');//moduleA就是模块名。保证派发的是moduleA里的incCount。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="19、Vue路由懒加载"><a href="#19、Vue路由懒加载" class="headerlink" title="19、Vue路由懒加载"></a>19、Vue路由懒加载</h2><p>vue的SPA（Single Page Application）应用里，当（webpack）打包构建时，会把所有的js打在一起，JavaScript 包会变得非常大，并在第一次请求时全部下载完毕，影响页面加载（性能）。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p><p>目前有三种方式实现路由组件的懒加载，分别是：</p><ul><li><p>Vue的异步组件</p></li><li><p>es的import()</p></li><li><p>webpack的require.ensure()</p><h4 id="1-、Vue异步组件"><a href="#1-、Vue异步组件" class="headerlink" title="1)、Vue异步组件"></a>1)、Vue异步组件</h4><p>把路由配置，进行修改</p><pre class="line-numbers language-none"><code class="language-none">{path: '/shopcar',name: 'shopcar',compontent: resoleve =&gt; require(['@/pages/ShopCar'],resoleve)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1）、运行时打开chrome的network，就会看到进入路由 /shopcar 时，会多出另外 一个js文件。一般是0.js或者1.js</p><p>2）、用npm run build打包时，wepback就会多打了一个 js文件（如：0.b5a82d6947b2e30edcc8.js），这个js文件就是把ShopCar文件进行了单独打包。同样的在network里，就会看到进入路由 /shopcar 时，多出一个单独的js文件的请求</p></li></ul><p>注：这种方式，webpack会把每个异步组件单独打成一个js文件。</p><h4 id="2）、es的import"><a href="#2）、es的import" class="headerlink" title="2）、es的import()"></a>2）、es的import()</h4><p>主要是把原来的引入方式进行修改 ，路由配置就不用改了：</p><h5 id="1、不指定webpackChunkName，每个组件单独打一个js文件"><a href="#1、不指定webpackChunkName，每个组件单独打一个js文件" class="headerlink" title="1、不指定webpackChunkName，每个组件单独打一个js文件"></a>1、不指定webpackChunkName，每个组件单独打一个js文件</h5><p>原来是：import ShopCar from ‘@/pages/ShopCar’</p><p>修改后：const ShopCar = () =&gt; import(‘@/pages/ShopCar’);</p><p>修改后的做法是定义了一个函数，由于函数不调用不执行，所有，一开始时，并不会引入该组件，只有路由跳转时才会调用该函数。</p><h5 id="2、指定webpackChunkName，相同的webpackChunkName就会打在同一个js文件里"><a href="#2、指定webpackChunkName，相同的webpackChunkName就会打在同一个js文件里" class="headerlink" title="2、指定webpackChunkName，相同的webpackChunkName就会打在同一个js文件里"></a>2、指定webpackChunkName，相同的webpackChunkName就会打在同一个js文件里</h5><p>1）、以下两个组件的webpackChunkName相同，所以，打在一个js文件里</p><pre class="line-numbers language-none"><code class="language-none">const ShopCar = () =&gt; import(/* webpackChunkName: 'demot' */ '@/pages/ShopCar');const GoodsDetailPage = () =&gt; import(/* webpackChunkName: 'demot' */ '@/pages/GoodsDetailPage');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2）、下面这个组件的webpackChunkName和上面两个不一样，所以，单独打在一个js文件里</p><pre class="line-numbers language-none"><code class="language-none">const Login = () =&gt; import(/* webpackChunkName: 'demoty' */ '@/pages/Login');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3）、webpack的require-ensure"><a href="#3）、webpack的require-ensure" class="headerlink" title="3）、webpack的require.ensure()"></a>3）、webpack的require.ensure()</h4><p>这种方式，只改路由配置即可。</p><p>如：</p><pre class="line-numbers language-none"><code class="language-none">{    path: '/GoodsDetailPage',    name: 'GoodsDetailPage',    component: r =&gt; require.ensure([], () =&gt; r(require('@/pages/GoodsDetailPage')), 'demot')},{    path: '/Login',    name: 'Login',    component: r =&gt; require.ensure([], () =&gt; r(require('@/pages/Login')), 'demot')},{    path: '/shopcar',    name: 'shopcar',        component: r =&gt; require.ensure([], () =&gt; r(require('@/pages/ShopCar')), 'demoty')},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中，我把Login和GoodsDetailPage使用了相同的chunkName</p><hr><h2 id="20、MV-（MVC-MVP-MVVM）"><a href="#20、MV-（MVC-MVP-MVVM）" class="headerlink" title="20、MV*（MVC,MVP,MVVM）"></a>20、MV*（MVC,MVP,MVVM）</h2><p>首先MVC，MVP，MVVM都是为了解决UI页面与逻辑代码分离而出现的模式，MVP和MVVM都是MVC的基础上演化而来。他不属于某种语言的框架，只要是有UI页面与逻辑代码我们都可以使用这几种框架去搭建我们的项目。他是一种框架模式。<br>        M和V分别指Model层和View层，但其功能会因为框架的不同而变化。Model层是数据模型，用来存储数据；View层是视图，展示Model层的数据。<br>        虽然在不同的MV(XX)框架中，Model层和View层的内容可能会有所差别，但是其基础功能不变，变的只是 数据的传输方式 。</p><h3 id="预热："><a href="#预热：" class="headerlink" title="预热："></a>预热：</h3><h6 id="MVC-—–-Model-View-Controller：作为-Controller-层的-Actvity-x2F-Fragment-等充当了-View-的角色，代码过于臃肿；同时在-View-层又容易直接操作-Model，导致-View-和-Model-层耦合，无法独立复用。有时候看到一个-Activity-能有几千甚至上万行的代码，简直噩梦。"><a href="#MVC-—–-Model-View-Controller：作为-Controller-层的-Actvity-x2F-Fragment-等充当了-View-的角色，代码过于臃肿；同时在-View-层又容易直接操作-Model，导致-View-和-Model-层耦合，无法独立复用。有时候看到一个-Activity-能有几千甚至上万行的代码，简直噩梦。" class="headerlink" title="MVC  —–  Model-View-Controller：作为 Controller 层的 Actvity/Fragment 等充当了 View 的角色，代码过于臃肿；同时在 View 层又容易直接操作 Model，导致 View 和 Model 层耦合，无法独立复用。有时候看到一个 Activity 能有几千甚至上万行的代码，简直噩梦。"></a>MVC  —–  Model-View-Controller：作为 Controller 层的 Actvity/Fragment 等充当了 View 的角色，代码过于臃肿；同时在 View 层又容易直接操作 Model，导致 View 和 Model 层耦合，无法独立复用。有时候看到一个 Activity 能有几千甚至上万行的代码，简直噩梦。</h6><h6 id="MVP-——-Model-View-Presenter-Presenter-和-View-层之间通过定义接口实现通信，解耦了-View-和-Model-层。然而当业务场景比较复杂时，接口定义会越来越多，且可能定义模糊，接口一旦变化，对应实现也需要发生变化。"><a href="#MVP-——-Model-View-Presenter-Presenter-和-View-层之间通过定义接口实现通信，解耦了-View-和-Model-层。然而当业务场景比较复杂时，接口定义会越来越多，且可能定义模糊，接口一旦变化，对应实现也需要发生变化。" class="headerlink" title="MVP —— Model-View-Presenter: Presenter 和 View 层之间通过定义接口实现通信，解耦了 View 和 Model 层。然而当业务场景比较复杂时，接口定义会越来越多，且可能定义模糊，接口一旦变化，对应实现也需要发生变化。"></a>MVP —— Model-View-Presenter: Presenter 和 View 层之间通过定义接口实现通信，解耦了 View 和 Model 层。然而当业务场景比较复杂时，接口定义会越来越多，且可能定义模糊，接口一旦变化，对应实现也需要发生变化。</h6><h6 id="MVVM-——-Model-View-ViewModel-MVVM-解决了-MVP-的问题，使得-ViewModel-和-View-之间不再依赖接口通信，而是通过-LiveData-RxJava-Flow-等响应式开发的方式来通信。"><a href="#MVVM-——-Model-View-ViewModel-MVVM-解决了-MVP-的问题，使得-ViewModel-和-View-之间不再依赖接口通信，而是通过-LiveData-RxJava-Flow-等响应式开发的方式来通信。" class="headerlink" title="MVVM —— Model-View-ViewModel: MVVM 解决了 MVP 的问题，使得 ViewModel 和 View 之间不再依赖接口通信，而是通过 LiveData, RxJava, Flow 等响应式开发的方式来通信。"></a>MVVM —— Model-View-ViewModel: MVVM 解决了 MVP 的问题，使得 ViewModel 和 View 之间不再依赖接口通信，而是通过 LiveData, RxJava, Flow 等响应式开发的方式来通信。</h6><h5 id="MVC："><a href="#MVC：" class="headerlink" title="MVC："></a>MVC：</h5><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写<br>        Model：模型层，数据模型及其业务逻辑，是针对业务模型建立的数据结构，Model与View无关，而与业务有关。<br>        View：视图层，用于与用户实现交互的页面，通常实现数据的输入和输出功能。<br>        Controller：控制器，用于连接Model层和View层，完成Model层和View层的交互。还可以处理页面业务逻辑，它接收并处理来自用户的请求，并将Model返回给用户。</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/1ecd7cdd734e43e7a8eb9a46edf18b36.png"></p><h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><p>耦合性低，生命周期成本低，部署快，可维护性高，适用于快速开发的小型项目</p><h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><p>不适合大型，中等项目，View层Controller层连接过于紧密；View层对Model层的访问效率低；一般的高级UI页面工具和构造器不支持MVC模式</p><h5 id="MVP："><a href="#MVP：" class="headerlink" title="MVP："></a>MVP：</h5><p> MVP全名是Model View Presenter，是模型(model)－视图(view)－表示器(Presenter)的缩写<br>        Model：模型层，用于数据存储以及业务逻辑。<br>        View：视图层，用于展示与用户实现交互的页面，通常实现数据的输入和输出功能。<br>        Presenter：表示器，用于连接M层、V层，完成Model层与View层的交互，还可以进行业务逻辑的处理。</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/2e5c150305574d5788fda5f759dfbeb4.png"></p><h6 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h6><p>1、View层收到用户的操作<br>2、View层把用户的操作交给Presenter<br>3、Presenter直接操作Model层进行业务逻辑处理<br>4、Model层处理完毕后，通知Presenter<br>5、Presenter收到通知后，去更新View层<br>        在MVP模式中，Model与View无法直接进行交互，所以Presenter层会从Model层获得数据，适当处理后交给View层进行显示<br>在MVP模式中，Presenter层将View层和Model层进行隔离，使View和Model之间不存在耦合，同时将业务逻辑从View层剥离</p><h6 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h6><p>​可以更高效的使用Model，所有的交互都发生在——Presenter内部<br>将一个Presenter用于多个视图，而不需要改变Presenter的逻辑，View变化比Model变化频繁，逻辑结构清晰，View层代码不再臃肿</p><h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h6><p>1、MVP模式基于接口设计，会增加很多类，代码逻辑虽然清晰，但代码量庞大2、MVP适用于中小型项目，大型项目慎用<br>3、MVC和MVP的主要区别：<br>4、MVP中View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互<br>5、MVP中Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View<br>6、MVP中Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。<br>7、MVC中View可以与Model直接交互，通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑</p><h5 id="MVVM："><a href="#MVVM：" class="headerlink" title="MVVM："></a>MVVM：</h5><p>MVVM 即 Model-View-ViewModel<br>        M——Model（模型）实体模型，定义实体类，获取业务数据模型，如通过数据库或者网络来操作数据等<br>        V——View（视图）布局文件(XML），主要进行控件的初始化设置<br>        VM——ViewModel（控制器）：连接 View 与 Model 的中间桥梁，ViewModel 与 Model 直接交互，通过DataBinding将数据变化反应给View</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/565ccf0115fe47e0afb2fe819a7c7e6d.png"></p><p> 存在两个方向都实现的情况，叫做数据的双向绑定。双向数据绑定可以说是一个模板引擎，它会根据数据的变化实时渲染。如图3.3所示，View层和Model层之间的修改都会同步到对方。</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/7682203377974fb6a025bb85877893aa.png"></p><h6 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h6><ol><li>结构清晰，职责划分清晰</li><li>模块间充分解耦</li><li>在 MVP 的基础上，MVVM 把 View 和 ViewModel 也进行了解耦</li></ol><h6 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h6><p>1、定位问题困难</p><p>从MVC到MVP再到MVVM，这是一个不断进步的过程，后两者都是在MVC基础上发展而来，使用起来更加方便。这三者主要的区别在于除Model层和View层之外的第三层的不同。</p><hr><h2 id="21、你了解Vue-js吗？"><a href="#21、你了解Vue-js吗？" class="headerlink" title="21、你了解Vue.js吗？"></a>21、你了解Vue.js吗？</h2><h5 id="1）、vueJS是基于MVVM的JS框架"><a href="#1）、vueJS是基于MVVM的JS框架" class="headerlink" title="1）、vueJS是基于MVVM的JS框架"></a>1）、vueJS是基于MVVM的JS框架</h5><h5 id="2）、有（常见的）13个指令："><a href="#2）、有（常见的）13个指令：" class="headerlink" title="2）、有（常见的）13个指令："></a>2）、有（常见的）13个指令：</h5><h5 id="3）、有（常见的）8个配置项：el，data，computed，watch，components，filter，directives，mixins"><a href="#3）、有（常见的）8个配置项：el，data，computed，watch，components，filter，directives，mixins" class="headerlink" title="3）、有（常见的）8个配置项：el，data，computed，watch，components，filter，directives，mixins"></a>3）、有（常见的）8个配置项：el，data，computed，watch，components，filter，directives，mixins</h5><h5 id="4）、vue实例生命周期分为四个阶段，八个生命周期函数"><a href="#4）、vue实例生命周期分为四个阶段，八个生命周期函数" class="headerlink" title="4）、vue实例生命周期分为四个阶段，八个生命周期函数"></a>4）、vue实例生命周期分为四个阶段，八个生命周期函数</h5><h5 id="5）、vue做项目时会用到的全家桶技术：vueJS框架，vueX，vue-router，aixos，vant组件库等等"><a href="#5）、vue做项目时会用到的全家桶技术：vueJS框架，vueX，vue-router，aixos，vant组件库等等" class="headerlink" title="5）、vue做项目时会用到的全家桶技术：vueJS框架，vueX，vue-router，aixos，vant组件库等等"></a>5）、vue做项目时会用到的全家桶技术：vueJS框架，vueX，vue-router，aixos，vant组件库等等</h5><hr><h2 id="22、Vue-router的两种路由模式的区别"><a href="#22、Vue-router的两种路由模式的区别" class="headerlink" title="22、Vue-router的两种路由模式的区别"></a>22、Vue-router的两种路由模式的区别</h2><p>路由模式分为两种：hash和history；通过设置vueRouter对象的mode属性来完成修改。</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><h5 id="1）、外观上："><a href="#1）、外观上：" class="headerlink" title="1）、外观上："></a>1）、外观上：</h5><h6 id="hash模式时，路径上由"><a href="#hash模式时，路径上由" class="headerlink" title="hash模式时，路径上由#"></a>hash模式时，路径上由#</h6><h6 id="history模式时，路径上没有"><a href="#history模式时，路径上没有" class="headerlink" title="history模式时，路径上没有#"></a>history模式时，路径上没有#</h6><h5 id="2）、原理上"><a href="#2）、原理上" class="headerlink" title="2）、原理上"></a>2）、原理上</h5><h6 id="（1）、hash模式通过修改location-href来完成"><a href="#（1）、hash模式通过修改location-href来完成" class="headerlink" title="（1）、hash模式通过修改location.href来完成"></a>（1）、hash模式通过修改location.href来完成</h6><p>使用锚点连接的思路，使用hash模式不会给后端发请求。当然，在hash值变化时，会同时触发window对象的onhashchange事件，并可以通过事件对象的oldURL属性和newURL属性 得到新旧URL。</p><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;    &lt;div&gt;        &lt;a href="#p01" &gt;p01&lt;/a&gt;&lt;br/&gt;        &lt;a href="#p02" &gt;p02&lt;/a&gt;&lt;br/&gt;        &lt;a href="#p03" &gt;p03&lt;/a&gt;    &lt;/div&gt;    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;a name="p01"&gt;我是第一个p&lt;/a&gt;    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;a name="p02"&gt;我是第二个p&lt;/a&gt;    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;a name="p03"&gt;我是第三个p&lt;/a&gt;    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;window.onhashchange = function(event){    console.log("旧url",event.oldURL);    console.log("新的url",event.newURL);}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="（2）、通过修改history-pushState来完成"><a href="#（2）、通过修改history-pushState来完成" class="headerlink" title="（2）、通过修改history.pushState来完成"></a>（2）、通过修改history.pushState来完成</h6><p>例：</p><pre class="line-numbers language-none"><code class="language-none">window.history.pushState(null,null,"p01.html");window.location.reload();//想测试的话，尽量加上这句话，要不然，地址变了，但是页面并没有出现。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>history模式会给后端发请求（如果刷新当前页面的话），一旦，后端和前端提供了同样的路径，那么，浏览器的请求结果就会有问题，到底是后端的资源还是前端的资源（不同的后端处理思路不停），还好，我们一般在后端apiserver的请求路径的前面习惯性的有个 /api。</p><p>所以，由于不同服务端的处理思路不同。所以，需要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面（单页面），这个页面就是你 app 依赖的页面。否则，就会返回404。</p><p>你可以改成history的模式，测试一下，如果刷新当前页面，那么，浏览器会朝后端发送请求（给当前路径）。</p><hr><h2 id="23、Vue路由守卫的三种方式，及其钩子函数和参数"><a href="#23、Vue路由守卫的三种方式，及其钩子函数和参数" class="headerlink" title="23、Vue路由守卫的三种方式，及其钩子函数和参数"></a>23、Vue路由守卫的三种方式，及其钩子函数和参数</h2><h4 id="1）、全局守卫"><a href="#1）、全局守卫" class="headerlink" title="1）、全局守卫"></a>1）、全局守卫</h4><p>全局守卫由前置守卫和后置守卫，是VueRouter对象的两个钩子函数，分别是beforeEach和afterEach。</p><h5 id="前置守卫："><a href="#前置守卫：" class="headerlink" title="前置守卫："></a>前置守卫：</h5><pre class="line-numbers language-none"><code class="language-none">router.beforeEach((to, from, next) =&gt; {    //  to: 目标路由    //  from: 当前路由    // next() 跳转  一定要调用    next(false);//不让走    next(true);//继续前行    next('/login')//走哪    next({path:'/detail/2',params:{},query:{}})//带点货 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="后置守卫："><a href="#后置守卫：" class="headerlink" title="后置守卫："></a>后置守卫：</h5><pre class="line-numbers language-none"><code class="language-none">router.afterEach((to,from)=&gt;{  //全局后置守卫业务})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h6 id="x2F-x2F-过程：-1、请求一个路径：如：-x2F-Index-2、经历前置守卫-决定了能去哪个路径-3、根据去的路径，找对应component（路由配置）-4、经过后置守卫-5、创建组件"><a href="#x2F-x2F-过程：-1、请求一个路径：如：-x2F-Index-2、经历前置守卫-决定了能去哪个路径-3、根据去的路径，找对应component（路由配置）-4、经过后置守卫-5、创建组件" class="headerlink" title="//过程： 1、请求一个路径：如：/Index 2、经历前置守卫 决定了能去哪个路径 3、根据去的路径，找对应component（路由配置） 4、经过后置守卫 5、创建组件"></a>//过程： 1、请求一个路径：如：/Index 2、经历前置守卫 决定了能去哪个路径 3、根据去的路径，找对应component（路由配置） 4、经过后置守卫 5、创建组件</h6><h4 id="2）、路由独享守卫"><a href="#2）、路由独享守卫" class="headerlink" title="2）、路由独享守卫"></a>2）、路由独享守卫</h4><p>写在路由配置里。钩子函数名：beforeEnter，只有前置守卫</p><p>例：</p><pre class="line-numbers language-none"><code class="language-none">// src/router/index.js{  path: '/user',  component: User,  beforeEnter: (to,from,next)=&gt;{ //路由独享守卫 前置     console.log('路由独享守卫');    if(Math.random()&lt;.5){      next()    }else{      next('/login')    }  } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3）、组件内部守卫"><a href="#3）、组件内部守卫" class="headerlink" title="3）、组件内部守卫"></a>3）、组件内部守卫</h4><p>写在组件对象里。分别有前置守卫，后置守卫，路由改变守卫（当前组件被复用的情况,不是路径改变）三个钩子函数。</p><pre class="line-numbers language-none"><code class="language-none">export default{    data(){return {}}  ……………………      //组件内部钩子    beforeRouteEnter (to, from, next) {//前置      // 不！能！获取组件实例 `this`      // 因为当守卫执行前，组件实例还没被创建    },    beforeRouteUpdate (to, from, next) {      // 在当前路由改变，但是该组件被复用时调用      // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，      // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。      // 可以访问组件实例 `this`    },    beforeRouteLeave (to, from, next) {//后置      // 导航离开该组件的对应路由时调用      // 可以访问组件实例 `this`    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="24、为何Vue采用异步渲染？"><a href="#24、为何Vue采用异步渲染？" class="headerlink" title="24、为何Vue采用异步渲染？"></a>24、为何Vue采用异步渲染？</h2><h4 id="1、vue采用异步队列渲染是为了提高性能，在异步队里会去掉重复的无效的渲染。"><a href="#1、vue采用异步队列渲染是为了提高性能，在异步队里会去掉重复的无效的渲染。" class="headerlink" title="1、vue采用异步队列渲染是为了提高性能，在异步队里会去掉重复的无效的渲染。"></a>1、vue采用异步队列渲染是为了提高性能，在异步队里会去掉重复的无效的渲染。</h4><h6 id="当vue中的数据发生改变后，vue框架会把该数据引起的dom更新放入异步队列（-缓冲在同一事件循环中发生的所有数据变更-），进行排队。-如果同一个-watcher-被多次触发，只会被推入到队列中一次-。-这种在缓冲时去除重复数据对于避免不必要的计算和-DOM-操作是非常重要的-。"><a href="#当vue中的数据发生改变后，vue框架会把该数据引起的dom更新放入异步队列（-缓冲在同一事件循环中发生的所有数据变更-），进行排队。-如果同一个-watcher-被多次触发，只会被推入到队列中一次-。-这种在缓冲时去除重复数据对于避免不必要的计算和-DOM-操作是非常重要的-。" class="headerlink" title="当vue中的数据发生改变后，vue框架会把该数据引起的dom更新放入异步队列（ 缓冲在同一事件循环中发生的所有数据变更 ），进行排队。 如果同一个 watcher 被多次触发，只会被推入到队列中一次 。 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的 。"></a>当vue中的数据发生改变后，vue框架会把该数据引起的dom更新放入异步队列（ 缓冲在同一事件循环中发生的所有数据变更 ），进行排队。 如果同一个 watcher 被多次触发，只会被推入到队列中一次 。 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的 。</h6><h4 id="2、如果不采用异步渲染，而是在数据发生改变后，立即更新dom，如果有重复无效的渲染，那么，就会造成性能的浪费。"><a href="#2、如果不采用异步渲染，而是在数据发生改变后，立即更新dom，如果有重复无效的渲染，那么，就会造成性能的浪费。" class="headerlink" title="2、如果不采用异步渲染，而是在数据发生改变后，立即更新dom，如果有重复无效的渲染，那么，就会造成性能的浪费。"></a>2、如果不采用异步渲染，而是在数据发生改变后，立即更新dom，如果有重复无效的渲染，那么，就会造成性能的浪费。</h4><hr><h2 id="25、nextTick实现原理？"><a href="#25、nextTick实现原理？" class="headerlink" title="25、nextTick实现原理？"></a>25、nextTick实现原理？</h2><h4 id="1）、为什么用Vue-nextTick"><a href="#1）、为什么用Vue-nextTick" class="headerlink" title="1）、为什么用Vue.nextTick()"></a>1）、为什么用Vue.nextTick()</h4><h5 id="首先，JS是单线程的，那么，它如何处理异步操作。"><a href="#首先，JS是单线程的，那么，它如何处理异步操作。" class="headerlink" title="首先，JS是单线程的，那么，它如何处理异步操作。"></a>首先，JS是单线程的，那么，它如何处理异步操作。</h5><ul><li>所有同步任务都在主线程上执行，形成一个<strong>执行栈</strong>。</li><li>主线程之外，会存在一个<strong>任务队列</strong>，只要异步任务有了结果，就在任务队列中放置一个事件（所以，也叫事件队列），进行<strong>排队</strong>（处于等待状态）</li><li>当执行栈中的所有同步任务执行完成，就会<strong>读取</strong>任务队列（事件队列）中的任务（事件）。即：任务队列中的任务就结束了等待状态，<strong>进入</strong>执行栈</li><li>主线程不断重复第三步。直到任务队列和执行栈里的代码执行完毕。</li></ul><p>其次，vue更新DOM的思路。使用的就是异步更新队列，所以，就使用了事件循环。目的是提高性能，避免无效的重复的DOM更新。即：vue中更新数据后，并不会立即更新DOM，而是把数据引起的DOM更新放入到异步更新队列里。等待下次事件循环（tick），并在两个tick之间进行UI渲染。这样程序员就不能在更改数据后，立即获取更新后的DOM，也不知道什么时候DOM能够更新。基于此，vue提供了nextTick函数。让程序员操作更新后DOM的代码放入到nextTick的回调函数里。由nextTick内部，在更新完DOM后，调用回调函数。</p><p>示例代码：</p><pre class="line-numbers language-none"><code class="language-none">this.msg = "hello"this.$nextTick(()=&gt;{     操作更新后DOM的代码。});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）、什么是Vue-nextTick"><a href="#2）、什么是Vue-nextTick" class="headerlink" title="2）、什么是Vue.nextTick()"></a>2）、什么是Vue.nextTick()</h4><p>Vue.nextTick的代码思路示意</p><pre class="line-numbers language-none"><code class="language-none">function nextTick(cb){//DOM 更新cb()}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>那么，Vue是如何知道DOM更新了？</p><ul><li>MutationObserver：这是HTML5新增的API。用于监视DOM变动的接口，它可以监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等</li><li>另外，考虑到，微任务比宏任务耗时少，浏览器的兼容性。所以，vue中延迟调用优先级如下： Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout</li></ul><h4 id="3）、应用场景："><a href="#3）、应用场景：" class="headerlink" title="3）、应用场景："></a>3）、应用场景：</h4><h6 id="在Vue生命周期的created-钩子函数里，如果要进行DOM操作，一定要把DOM操作放在Vue-nextTick-的回调函数中。"><a href="#在Vue生命周期的created-钩子函数里，如果要进行DOM操作，一定要把DOM操作放在Vue-nextTick-的回调函数中。" class="headerlink" title="在Vue生命周期的created()钩子函数里，如果要进行DOM操作，一定要把DOM操作放在Vue.nextTick()的回调函数中。"></a>在Vue生命周期的created()钩子函数里，如果要进行DOM操作，一定要把DOM操作放在Vue.nextTick()的回调函数中。</h6><h6 id="在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue-nextTick-的回调函数中。"><a href="#在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue-nextTick-的回调函数中。" class="headerlink" title="在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue.nextTick()的回调函数中。"></a>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue.nextTick()的回调函数中。</h6><hr><h2 id="26、JS的事件循环"><a href="#26、JS的事件循环" class="headerlink" title="26、JS的事件循环"></a>26、JS的事件循环</h2><h4 id="JS是单线程的，那么，它如何处理异步操作？"><a href="#JS是单线程的，那么，它如何处理异步操作？" class="headerlink" title="JS是单线程的，那么，它如何处理异步操作？"></a>JS是单线程的，那么，它如何处理异步操作？</h4><h5 id="答：使用事件循环，执行过程如下："><a href="#答：使用事件循环，执行过程如下：" class="headerlink" title="答：使用事件循环，执行过程如下："></a>答：使用事件循环，执行过程如下：</h5><ul><li><p>所有</p></li><li><p>所有同步任务都在主线程上执行，形成一个执行栈。</p></li><li><p>主线程之外，会存在一个任务队列，只要异步任务有了结果（如：setTimeout的等待时间到了），就在任务队列中放置一个事件（所以，也叫事件队列），进行排队（处于等待状态）。</p></li><li><p>当执行栈中的所有同步任务执行完后，就会读取任务队列（事件队列）中的任务（事件）。即：任务队列中的任务就结束了等待状态，进入执行栈。</p></li><li><p>主线程不断重复第三步。直到任务队列和执行栈里的代码执行完毕。</p><h4 id="1、执行栈"><a href="#1、执行栈" class="headerlink" title="1、执行栈"></a>1、执行栈</h4><p>注意，执行栈不是内存的栈区。</p><p>在JS中，当很多函数被依次调用的时候，因为js是单线程的，同一时间只能执行一个函数，怎么办？不能同时来，得排个队，排个一子队，按照顺序来，那这个一子队的顺序，即哪个函数在前，哪个函数在后，谁来记录呢？js为此专门开辟了一个内存区域，起名叫做执行栈。在执行栈里，保存着即将要执行的函数。就像大家在学校里排队打饭一样，只有一个人给你打饭时，你就老老实实地排队，一个打完饭了，下一个再打。</p><p>​当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个函数，那么js会向执行栈中添加这个函数的执行环境（当我们调用一个函数的时候，js会生成一个与这个函数对应的执行环境（context），又叫执行上下文。这个执行环境中保存着这个函数的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。），然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。</p><h4 id="2、事件队列"><a href="#2、事件队列" class="headerlink" title="2、事件队列"></a>2、事件队列</h4><p> 以上说的是同步执行的情况，如果出现了异步（如发送ajax请求数据）执行，就需要用到事件队列，或者叫做任务队列（Task Queue）。</p><p> js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中下面的任务。执行过程中，当这个异步事件被触发时（异步任务有了结果，如setTimeout的等待世间到了），把该事件加入一个队列里，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p><p>即：执行栈存放所有要执行的函数（代码），事件队列中存放所有的异步任务，如果执行栈中的代码执行完毕后，才会把事件队列中的事件（所有异步的代码）放入执行栈，接着执行。</p></li></ul><p>这也是为什么如下代码的执行，与你想象的不一样的原因所在。</p><pre><code>          setTimeout（function(){                     console.log(1);             }, 0）             console.log(2);</code></pre><p>的执行结果是在后台分别打印出： 2   1</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/20190714174959220.png"></p><h4 id="3、事件队列里分为：宏任务队列和微任务队列"><a href="#3、事件队列里分为：宏任务队列和微任务队列" class="headerlink" title="3、事件队列里分为：宏任务队列和微任务队列"></a>3、事件队列里分为：宏任务队列和微任务队列</h4><h5 id="1）、宏任务（macrotask）"><a href="#1）、宏任务（macrotask）" class="headerlink" title="1）、宏任务（macrotask）"></a>1）、宏任务（macrotask）</h5><h6 id="宏任务一般包括：-setTimeout，setInterval，I-x2F-O-操作（包括AJAX请求），即上面的示例中setTimeout是宏任务。"><a href="#宏任务一般包括：-setTimeout，setInterval，I-x2F-O-操作（包括AJAX请求），即上面的示例中setTimeout是宏任务。" class="headerlink" title="宏任务一般包括： setTimeout，setInterval，I/O 操作（包括AJAX请求），即上面的示例中setTimeout是宏任务。"></a>宏任务一般包括： setTimeout，setInterval，I/O 操作（包括AJAX请求），即上面的示例中setTimeout是宏任务。</h6><h5 id="2）、微任务（microtask）"><a href="#2）、微任务（microtask）" class="headerlink" title="2）、微任务（microtask）"></a>2）、微任务（microtask）</h5><h6 id="微任务一般包括：promise-then-里的操作"><a href="#微任务一般包括：promise-then-里的操作" class="headerlink" title="微任务一般包括：promise.then()里的操作"></a>微任务一般包括：promise.then()里的操作</h6><h4 id="4、当宏任务碰到了微任务时"><a href="#4、当宏任务碰到了微任务时" class="headerlink" title="4、当宏任务碰到了微任务时"></a>4、当宏任务碰到了微任务时</h4><p>那么问题来了，当执行栈里的代码执行完毕，去事件队列里取任务时，先去微任务队列里的任务还是先去宏任务里的任务呢？</p><h6 id="答：先取微任务里的任务。因为，微任务耗时少，快。"><a href="#答：先取微任务里的任务。因为，微任务耗时少，快。" class="headerlink" title="答：先取微任务里的任务。因为，微任务耗时少，快。"></a>答：先取微任务里的任务。因为，微任务耗时少，快。</h6><h4 id="5、示例：当宏任务碰到了微任务时"><a href="#5、示例：当宏任务碰到了微任务时" class="headerlink" title="5、示例：当宏任务碰到了微任务时"></a>5、示例：当宏任务碰到了微任务时</h4><pre class="line-numbers language-none"><code class="language-none">console.log(1); //主线程 setTimeout(function(){    console.log(2);//这个是宏任务，不管时间是多少（就算是0），都会进入到宏任务},0); new Promise(function(resolve,reject){    resolve();//这个是then的回调函数，这个会进入到微任务}).then(function(){    console.log(3);}); console.log(4);//主线程   // 以上打印结果是：1,4,3,2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6、示例：当宏任务碰到了微任务时"><a href="#6、示例：当宏任务碰到了微任务时" class="headerlink" title="6、示例：当宏任务碰到了微任务时"></a>6、示例：当宏任务碰到了微任务时</h4><p>多啰嗦一句，注意：在Promise的回调函数里的代码是同步，then里的回调才是异步的（resolve()）</p><pre class="line-numbers language-none"><code class="language-none">console.log(1); //主线程 setTimeout(function(){    console.log(2);//这个是宏任务，不管时间是多少（就算是0），也会进入到宏任务},0); new Promise(function(resolve,reject){    console.log(3); //Promise里的代码是同步的 （这行代码是新加的），所以，一开始在主线程执行    resolve();//这个是then的回调函数，这个是进入到微任务}).then(function(){    console.log(4);}); console.log(5); // 以上打印结果是：1,3,5,4,2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7、示例：Promise，async，await，setTimeout"><a href="#7、示例：Promise，async，await，setTimeout" class="headerlink" title="7、示例：Promise，async，await，setTimeout"></a>7、示例：Promise，async，await，setTimeout</h4><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;/body&gt;&lt;/html&gt;&lt;script&gt; console.log(0); //主线程 setTimeout(function(){    console.log(1);//宏任务},1000); setTimeout(function(){    console.log(2);//宏任务},0); new Promise(function(resolve,reject){    console.log(3);//主线程    resolve(); //微任务}).then(()=&gt;{    console.log(4);//微任务，这个then里的回调代码就是resolve});  async function async1(){    console.log(5); //同步，主线程    let temp =  await async2(); //async2函数里有promise    console.log(temp);    console.log(6);    return "async1";} async function async2(){    console.log(7); //同步    return "async2";} async1(); console.log(8);//主线程， // 以上打印结果是：0，3，5，7，8，4，async2里的promise.then(), 6, async1里的promise.then(),2,1 &lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="27、何时需要使用beforeDestroy？"><a href="#27、何时需要使用beforeDestroy？" class="headerlink" title="27、何时需要使用beforeDestroy？"></a>27、何时需要使用beforeDestroy？</h2><p>总体来说，需要清除的是：当前组件不会自动销毁的数据（不属于当前组件的数据），并且该数据只是在当前组件里使用。</p><h6 id="1）、清楚定时器（定时器是window对象的，不主动清楚，是不会清楚的）"><a href="#1）、清楚定时器（定时器是window对象的，不主动清楚，是不会清楚的）" class="headerlink" title="1）、清楚定时器（定时器是window对象的，不主动清楚，是不会清楚的）"></a>1）、清楚定时器（定时器是window对象的，不主动清楚，是不会清楚的）</h6><h6 id="2）、-on方法，那需要在组件销毁前解绑。（-on虽然属于Vue的实例方法，但是，这个实例很有可能不是当前vue组件（如：事件总线中的用法））"><a href="#2）、-on方法，那需要在组件销毁前解绑。（-on虽然属于Vue的实例方法，但是，这个实例很有可能不是当前vue组件（如：事件总线中的用法））" class="headerlink" title="2）、$on方法，那需要在组件销毁前解绑。（$on虽然属于Vue的实例方法，但是，这个实例很有可能不是当前vue组件（如：事件总线中的用法））"></a>2）、$on方法，那需要在组件销毁前解绑。（$on虽然属于Vue的实例方法，但是，这个实例很有可能不是当前vue组件（如：事件总线中的用法））</h6><h6 id="3）、解除事件的绑定-scroll-mousemove（这些事件是绑定在window对象或者document对象上的）"><a href="#3）、解除事件的绑定-scroll-mousemove（这些事件是绑定在window对象或者document对象上的）" class="headerlink" title="3）、解除事件的绑定 scroll mousemove（这些事件是绑定在window对象或者document对象上的）"></a>3）、解除事件的绑定 scroll mousemove（这些事件是绑定在window对象或者document对象上的）</h6><hr><h2 id="28、Vue中的-v-html会导致哪些问题"><a href="#28、Vue中的-v-html会导致哪些问题" class="headerlink" title="28、Vue中的 v-html会导致哪些问题"></a>28、Vue中的 v-html会导致哪些问题</h2><h6 id="1）、可能会导致XSS攻击。因为V-html更新的是元素的innerHTML。内容按普通-HTML-插入，-不会作为-Vue-模板进行编译-。"><a href="#1）、可能会导致XSS攻击。因为V-html更新的是元素的innerHTML。内容按普通-HTML-插入，-不会作为-Vue-模板进行编译-。" class="headerlink" title="1）、可能会导致XSS攻击。因为V-html更新的是元素的innerHTML。内容按普通 HTML 插入， 不会作为 Vue 模板进行编译 。"></a>1）、可能会导致XSS攻击。因为V-html更新的是元素的innerHTML。内容按普通 HTML 插入， 不会作为 Vue 模板进行编译 。</h6><h6 id="2）、在单文件组件里，scoped的样式不会应用在v-html内部。因为那部分HTML没有被Vue的模板编辑器处理。怎么解决呢？如果你希望针对-v-html-的内容设置带······作用域的-CSS，你可以替换为-CSS-Modules-或用一个额外的全局-元素手动设置类似-BEM-的作用域策略。"><a href="#2）、在单文件组件里，scoped的样式不会应用在v-html内部。因为那部分HTML没有被Vue的模板编辑器处理。怎么解决呢？如果你希望针对-v-html-的内容设置带······作用域的-CSS，你可以替换为-CSS-Modules-或用一个额外的全局-元素手动设置类似-BEM-的作用域策略。" class="headerlink" title="2）、在单文件组件里，scoped的样式不会应用在v-html内部。因为那部分HTML没有被Vue的模板编辑器处理。怎么解决呢？如果你希望针对 v-html 的内容设置带······作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局 元素手动设置类似 BEM 的作用域策略。"></a>2）、在单文件组件里，scoped的样式不会应用在v-html内部。因为那部分HTML没有被Vue的模板编辑器处理。怎么解决呢？如果你希望针对 v-html 的内容设置带······作用域的 CSS，你可以替换为 CSS Modules 或用一个额外的全局 元素手动设置类似 BEM 的作用域策略。</h6><h6 id="3）、后台返回的html片段，以及CSS样式和JS，但是返回的JS是不执行的，因为浏览器在渲染的时候并没有将JS渲染，这时要在-nextTick中动态创建script标签并插入"><a href="#3）、后台返回的html片段，以及CSS样式和JS，但是返回的JS是不执行的，因为浏览器在渲染的时候并没有将JS渲染，这时要在-nextTick中动态创建script标签并插入" class="headerlink" title="3）、后台返回的html片段，以及CSS样式和JS，但是返回的JS是不执行的，因为浏览器在渲染的时候并没有将JS渲染，这时要在$nextTick中动态创建script标签并插入"></a>3）、后台返回的html片段，以及CSS样式和JS，但是返回的JS是不执行的，因为浏览器在渲染的时候并没有将JS渲染，这时要在$nextTick中动态创建script标签并插入</h6><hr><h6 id="29、为什么v-for与v-if不能连用"><a href="#29、为什么v-for与v-if不能连用" class="headerlink" title="29、为什么v-for与v-if不能连用"></a>29、为什么v-for与v-if不能连用</h6><p>应该说，建议不要连用，或者说，在循环时，通过if只能拿到少部分数据时，建议不要使用。</p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><h6 id="v-for比v-if优先级高，如果遍历的数组元素个数比较多，但是满足v-if条件比较少的情况下。会浪费性能。而且，每次刷新页面时，都会执行这样性能不高的代码。"><a href="#v-for比v-if优先级高，如果遍历的数组元素个数比较多，但是满足v-if条件比较少的情况下。会浪费性能。而且，每次刷新页面时，都会执行这样性能不高的代码。" class="headerlink" title="v-for比v-if优先级高，如果遍历的数组元素个数比较多，但是满足v-if条件比较少的情况下。会浪费性能。而且，每次刷新页面时，都会执行这样性能不高的代码。"></a>v-for比v-if优先级高，如果遍历的数组元素个数比较多，但是满足v-if条件比较少的情况下。会浪费性能。而且，每次刷新页面时，都会执行这样性能不高的代码。</h6><h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><h6 id="可以在computed里循环数组，通过filter的方式，过滤出需要的数据。v-for直接循环计算属性的结果（不用v-if）。而computed是有缓存的，所以，在原始数据没有变化时，不会多次过滤数据，这样，就提高了效率。"><a href="#可以在computed里循环数组，通过filter的方式，过滤出需要的数据。v-for直接循环计算属性的结果（不用v-if）。而computed是有缓存的，所以，在原始数据没有变化时，不会多次过滤数据，这样，就提高了效率。" class="headerlink" title="可以在computed里循环数组，通过filter的方式，过滤出需要的数据。v-for直接循环计算属性的结果（不用v-if）。而computed是有缓存的，所以，在原始数据没有变化时，不会多次过滤数据，这样，就提高了效率。"></a>可以在computed里循环数组，通过filter的方式，过滤出需要的数据。v-for直接循环计算属性的结果（不用v-if）。而computed是有缓存的，所以，在原始数据没有变化时，不会多次过滤数据，这样，就提高了效率。</h6><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">computed:{    isCompleteTask:function(){        return this.todos.filter(item=&gt;item.isComplete);    }          }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="31、如何自定义v-model"><a href="#31、如何自定义v-model" class="headerlink" title="31、如何自定义v-model"></a>31、如何自定义v-model</h2><p>答：使用vue组件中的选项model。</p><p>首先，官方组件里可以使用v-model。而且，vue框架针对官方组件（文本框，单选钮，复选框，下拉框）都有绑定的属性和事件。如：文本框所绑定的属性是value，绑定的事件是input。</p><p>那么，自定义组件里，如何使用v-model指令。</p><h5 id="1、自定义组件里使用v-model指令，默认会使用value属性和input事件。"><a href="#1、自定义组件里使用v-model指令，默认会使用value属性和input事件。" class="headerlink" title="1、自定义组件里使用v-model指令，默认会使用value属性和input事件。"></a>1、自定义组件里使用v-model指令，默认会使用value属性和input事件。</h5><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="app"&gt;        &lt;p&gt;{{str}}&lt;/p&gt;        &lt;hr/&gt;         &lt;chat v-model="str" &gt;&lt;/chat&gt;    &lt;/div&gt;    &lt;hr /&gt;&lt;/body&gt; &lt;/html&gt;&lt;script src="./js/vue2.js"&gt;&lt;/script&gt;&lt;script&gt;Vue.component("chat",{    props:["value"],        template:`        &lt;div&gt;            &lt;p&gt;{{value}}&lt;/p&gt;            &lt;input type="text"  /&gt;            &lt;input type="button" value="修改value" @click="changeVal"  /&gt;                    &lt;/div&gt;    `,    data(){        return {}    },    methods:{        changeVal(){            this.$emit("input","新值");        }    }}) let vm = new Vue({    el:"#app",    data:{        str:"hello str"    }})  &lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2、如果，想修改属性名和事件名，就需要在VUE组件里增加model选项。"><a href="#2、如果，想修改属性名和事件名，就需要在VUE组件里增加model选项。" class="headerlink" title="2、如果，想修改属性名和事件名，就需要在VUE组件里增加model选项。"></a>2、如果，想修改属性名和事件名，就需要在VUE组件里增加model选项。</h5><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">Vue.component('my-checkbox', {  props:['ccc','ddd'],//声明了自定义组件的属性。  model: {    prop: 'ccc', //表示v-model所绑定的属性是 ccc    event: 'change'//表示v-model所绑定的事件是是 change  },  ……………………}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题合集--JS</title>
      <link href="/2023/01/17/mian-shi-ti-he-ji-js/"/>
      <url>/2023/01/17/mian-shi-ti-he-ji-js/</url>
      
        <content type="html"><![CDATA[<h2 id="1、let-与-var"><a href="#1、let-与-var" class="headerlink" title="1、let 与 var"></a>1、let 与 var</h2><p>答：</p><p>var  =&gt;  1.声明提升</p><p>​  2.没有局部作用域</p><p>​  3.声明覆盖</p><hr><h2 id="2、深拷贝与浅拷贝"><a href="#2、深拷贝与浅拷贝" class="headerlink" title="2、深拷贝与浅拷贝"></a>2、深拷贝与浅拷贝</h2><p>深拷贝和浅拷贝主要针对对象的属性是对象（引用类型）</p><h3 id="一、基本类型和引用类型的区别"><a href="#一、基本类型和引用类型的区别" class="headerlink" title="一、基本类型和引用类型的区别"></a>一、基本类型和引用类型的区别</h3><h5 id="1-先了解内存"><a href="#1-先了解内存" class="headerlink" title="1.先了解内存"></a>1.先了解内存</h5><p>任何编程语言的内存分区几乎都是一样的</p><p>内存是存储数据的，不同类型的数据要存储在不同的区域，及分类存放，不同的区域作用和功能也不一样。</p><p>以下为内存的分区图。内存分为四个区域：栈区（堆栈），堆区，全局静态区，只读区（常量区和代码区）</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/QQ图片20230117203930.png"></p><p>1、栈区</p><p>1）存放的数据：局部变量，形参，被调用函数的地址（这个可以不用管）等等。</p><p> 2）特点：</p><p>读取速度快，存储和释放的思路是按照数据结构中的栈进行的，存数据就是压栈，释放就是弹栈。</p><p>空间小，基本类型的数据占用空间的大小不会随着值的改变而改变，而且占用空间小。</p><p>2、堆区：</p><p> 1）、存放数据：new出来的数据。</p><p>2）、特点： 读取速度慢</p><p>​   空间大：引用类型的数据大小是动态的，会随着数据的增加而改变大小</p><p>3、全局静态区：</p><p>1）、存放数据：全局变量和静态变量</p><p>2）、特点：在程序运行过程中，数据会一直在内存中。</p><p>4、只读区：</p><p>1）、存放数据：常量区存放常量，代码区存放程序的代码（程序运行时是需要载入到内存中允许的）</p><p>2）、特点：此区域的数据在程序运行过程中肯定不能改变。</p><h5 id="2-基本类型和引用类型在内存存储的区别"><a href="#2-基本类型和引用类型在内存存储的区别" class="headerlink" title="2.基本类型和引用类型在内存存储的区别"></a>2.基本类型和引用类型在内存存储的区别</h5><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/20190807124758680.png"></p><p>以上函数test在调用时，</p><p>   1）、 定义局部变量 age，由于age是局部变量，所以在栈中申请内存空间，起名为age，又由于给age赋的值250是基本类型，所以，值直接存储在栈中。</p><p>   2）、定义局部变量arr，由于arr是局部变量，所以在栈中申请空间，但是arr的内存中存储的是什么？由于给arr赋的值不是基本类型，而是引用类型（new出来的），所以，先在堆中申请空间存放数据 12,23,34,。再把堆区的地址赋给arr。</p><h5 id="3、到底什么是基本类型和引用类型"><a href="#3、到底什么是基本类型和引用类型" class="headerlink" title="3、到底什么是基本类型和引用类型"></a>3、到底什么是基本类型和引用类型</h5><p>1）、基本类型：就是值类型，即在变量所对应的内存区域存储的是值，如：上面的age变量所对应的内存存储的就是值250.</p><p>2）、引用类型：就是地址类型。</p><p>何为地址：地址就是编号，要地址何用，就是为了容易找到。每个人的家里为什么要有一个唯一的地址，就是在邮寄时，能够找到你家。</p><p>比如：我们最早的超市存包的格子，每个格子都有个编号，你存包时，服务员会把你的东西放在某个格子里，再把这个格子的编号给你（一个牌子）。你购物完毕取包时，直接给服务员你的牌子（有编号），服务员根据你的编号就会找到你的包。这个编号就是格子的地址。内存也是一样的，每个内存都有一个编号，方便cpu查找。要不然，浩瀚的内存海洋，cpu要找到数据靠啥找。</p><p>以上的变量arr就是引用类型，arr所对应的内存中存储着地址，真正的数据是在地址对应的内存区域里，就像，你填写简历时，会在简历的那张纸上写上你家的地址。简历上写你家地址的地方就相当于arr。而你家是根据这个地址可以找到的。简历上写你家地址的地方就相当于引用着你家（可以想象一根无形的线牵引着你家，在简历上的这根无形的线，顺藤摸瓜就能找到你家）。所以叫做引用类型。</p><h3 id="二、基本类型和引用类型在赋值时内存的变化"><a href="#二、基本类型和引用类型在赋值时内存的变化" class="headerlink" title="二、基本类型和引用类型在赋值时内存的变化"></a>二、基本类型和引用类型在赋值时内存的变化</h3><p>你可以认为，赋值就是在拷贝。</p><h5 id="1、基本类型："><a href="#1、基本类型：" class="headerlink" title="1、基本类型："></a>1、基本类型：</h5><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/基本类型.png"></p><h5 id="2、引用类型："><a href="#2、引用类型：" class="headerlink" title="2、引用类型："></a>2、引用类型：</h5><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/引用类型.png"></p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>其实在第二点已经说到了拷贝，所谓拷贝，就是赋值。把一个变量赋给另外一个变量，就是把变量的内容进行拷贝。把一个对象的值赋给另外一个对象，就是把一个对象拷贝一份。</p><h3 id="1、基本类没有问题，"><a href="#1、基本类没有问题，" class="headerlink" title="1、基本类没有问题，"></a>1、基本类没有问题，</h3><p>因为，基本类型赋值时，赋的是数据（所以，不存在深拷贝和浅拷贝的问题）。</p><p>​    如：</p><p>  Var x = 100;</p><p>  Var y = x; //此时x和y都是100;</p><p>  如果要改变y的值，x的值不会改变。</p><h3 id="2、引用类型有问题"><a href="#2、引用类型有问题" class="headerlink" title="2、引用类型有问题"></a>2、引用类型有问题</h3><p>  因为，引用类型赋值时，赋的值地址（就是引用类型变量在内存中保存的内容），强烈建议把前面的第二点（基本类型和引用类型在赋值时内存的变化）多看几遍，以保证理解深刻。这样，一劳永逸，以后在碰到任何跟引用类型有关的话题（如：继承时，父类的属性是引用类型）都没有问题。</p><p>如：</p><p>var arr1 = new Array(12,23,34)</p><p>Var arr2 = arr1;//这就是一个最简单的浅拷贝</p><p>如果要改变arr2所引用的数据：arr2[0]=100时，那么arr1[0]的值也是100。</p><p>​    原因就是 arr1和arr2引用了同一块内存区域（以上的第二点中有体现）。</p><h3 id="3、用json对象的方式-（也是引用类型）来演示浅拷贝和深拷贝"><a href="#3、用json对象的方式-（也是引用类型）来演示浅拷贝和深拷贝" class="headerlink" title="3、用json对象的方式 （也是引用类型）来演示浅拷贝和深拷贝"></a>3、用json对象的方式 （也是引用类型）来演示浅拷贝和深拷贝</h3><h5 id="1）、定义一个json对象（对象的属性也是对象）"><a href="#1）、定义一个json对象（对象的属性也是对象）" class="headerlink" title="1）、定义一个json对象（对象的属性也是对象）"></a>1）、定义一个json对象（对象的属性也是对象）</h5><pre class="line-numbers language-none"><code class="language-none">let p = {"id":"007","name":"刘德华","books": new Array("三国","水浒传","红楼梦")}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内存图：</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/内存图.png"></p><h5 id="2）、把该对象p进行复制一份"><a href="#2）、把该对象p进行复制一份" class="headerlink" title="2）、把该对象p进行复制一份"></a>2）、把该对象p进行复制一份</h5><h5 id="（一）浅拷贝-引用类型浅拷贝，基本类型深拷贝"><a href="#（一）浅拷贝-引用类型浅拷贝，基本类型深拷贝" class="headerlink" title="（一）浅拷贝(引用类型浅拷贝，基本类型深拷贝)"></a>（一）浅拷贝(引用类型浅拷贝，基本类型深拷贝)</h5><pre class="line-numbers language-none"><code class="language-none">let p2 = {};for(let key in p){p2[key] = p[key];}p2.books[0] = "四国";console.log(p2);console.log(p);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在控制台中打印的结果（p和p2的books[0]都变成了“四国”）：</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/20190807125636194.png"></p><p>内存：</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/20190807125742367.png"></p><h5 id="二-深拷贝（初步）"><a href="#二-深拷贝（初步）" class="headerlink" title="(二)深拷贝（初步）"></a>(二)深拷贝（初步）</h5><pre class="line-numbers language-none"><code class="language-none">var p2 = {};for(let key in p){if(typeof p[key]=='object'){p2[key]=[];//因为,我上面写的是数组,所以,暂时赋值一个空数组.for(let i in p[key]){p2[key][i] = p[key][i]}}else{p2[key] = p[key];}}p2.books[0] ="四国";console.log(p2);console.log(p)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在控制台中打印的结果（只有p2的books[0]变成了“四国”）</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/20190807125846495.png"></p><p>内存：</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/20190807125947792.png"></p><h5 id="深拷贝-（最终）"><a href="#深拷贝-（最终）" class="headerlink" title="(深拷贝)（最终）"></a>(深拷贝)（最终）</h5><h6 id="3-1、深拷贝-如果属性都是json对象，那么用递归的方式"><a href="#3-1、深拷贝-如果属性都是json对象，那么用递归的方式" class="headerlink" title="3.1、深拷贝_如果属性都是json对象，那么用递归的方式"></a>3.1、深拷贝_如果属性都是json对象，那么用递归的方式</h6><p>如果对象的属性是对象(引用类型),属性的属性也是引用类型,即层层嵌套很多.怎么办,只能递归</p><p>如下对象</p><pre class="line-numbers language-none"><code class="language-none">var p = {"id":"007","name":"刘德华","wife":{"id":"008","name":"刘德的妻子","address":{"city":"北京","area":"海淀区"}}}//写函数function copyObj(obj){let newObj={};for(let key in obj){if(typeof obj[key] =='object'){//如:key是wife,引用类型,那就递归newObj[key] = copyObj(obj[key])}else{//基本类型,直接赋值newObj[key] = obj[key];}}return newObj;}let pNew = copyObj(p);pNew.wife.name="张三疯";pNew.wife.address.city = "香港";console.log(pNew);console.log(p);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/20190807130050596.png"></p><h6 id="3-2、深拷贝-如果属性是数组等非键值对的对象"><a href="#3-2、深拷贝-如果属性是数组等非键值对的对象" class="headerlink" title="3.2、深拷贝_如果属性是数组等非键值对的对象"></a>3.2、深拷贝_如果属性是数组等非键值对的对象</h6><p>需要单独处理：</p><pre class="line-numbers language-none"><code class="language-none">//给数组对象增加一个方法，用来复制自己Array.prototype.copyself = function(){let arr = new Array();for(let i in this){arr[i]  = this[i]}return arr;} var p = {"id":"007","name":"刘德华","books":new Array("三国演义","红楼梦","水浒传")//这是引用类型} function copyObj(obj){let newObj={};for(let key in obj){if(typeof obj[key] =='object'){//如:key是wife,引用类型,那就递归newObj[key] = obj[key].copyself();}else{//基本类型,直接赋值newObj[key] = obj[key];}}return newObj;} var pNew = copyObj(p);pNew.books[0] = "四国";console.log(pNew);console.log(p);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/20190807130143411.png"></p><hr><h2 id="3、引用类型和基本类型的区别"><a href="#3、引用类型和基本类型的区别" class="headerlink" title="3、引用类型和基本类型的区别"></a>3、引用类型和基本类型的区别</h2><h5 id="基本类型：Undefined、String、Number、Null、Boolean、Symbol"><a href="#基本类型：Undefined、String、Number、Null、Boolean、Symbol" class="headerlink" title="基本类型：Undefined、String、Number、Null、Boolean、Symbol"></a>基本类型：Undefined、String、Number、Null、Boolean、Symbol</h5><h5 id="引用类型：统称为Object类型"><a href="#引用类型：统称为Object类型" class="headerlink" title="引用类型：统称为Object类型"></a>引用类型：统称为Object类型</h5><h5 id="1）、内存角度："><a href="#1）、内存角度：" class="headerlink" title="1）、内存角度："></a>1）、内存角度：</h5><h6 id="基本类型在内存中，占据一块空间，空间里存储的就是数据，获取数据是直接获取"><a href="#基本类型在内存中，占据一块空间，空间里存储的就是数据，获取数据是直接获取" class="headerlink" title="基本类型在内存中，占据一块空间，空间里存储的就是数据，获取数据是直接获取"></a>基本类型在内存中，占据一块空间，空间里存储的就是数据，获取数据是直接获取</h6><h6 id="引用类型在内存中，占据两块空间，第一块存储的是地址，第二块存储的是数据，获取数据是属间接取值"><a href="#引用类型在内存中，占据两块空间，第一块存储的是地址，第二块存储的是数据，获取数据是属间接取值" class="headerlink" title="引用类型在内存中，占据两块空间，第一块存储的是地址，第二块存储的是数据，获取数据是属间接取值"></a>引用类型在内存中，占据两块空间，第一块存储的是地址，第二块存储的是数据，获取数据是属间接取值</h6><h5 id="2）、赋值的角度"><a href="#2）、赋值的角度" class="headerlink" title="2）、赋值的角度"></a>2）、赋值的角度</h5><h6 id="基本类型赋的就是值"><a href="#基本类型赋的就是值" class="headerlink" title="基本类型赋的就是值"></a>基本类型赋的就是值</h6><h6 id="引用类型赋的就是地址"><a href="#引用类型赋的就是地址" class="headerlink" title="引用类型赋的就是地址"></a>引用类型赋的就是地址</h6><h5 id="3）、函数传参"><a href="#3）、函数传参" class="headerlink" title="3）、函数传参"></a>3）、函数传参</h5><h6 id="基本类型传的就是值"><a href="#基本类型传的就是值" class="headerlink" title="基本类型传的就是值"></a>基本类型传的就是值</h6><h6 id="引用类型传的就是地址"><a href="#引用类型传的就是地址" class="headerlink" title="引用类型传的就是地址"></a>引用类型传的就是地址</h6><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题合集-CSS</title>
      <link href="/2023/01/17/mian-shi-ti-he-ji-css/"/>
      <url>/2023/01/17/mian-shi-ti-he-ji-css/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS–快速布局居中对齐"><a href="#CSS–快速布局居中对齐" class="headerlink" title="CSS–快速布局居中对齐"></a>CSS–快速布局居中对齐</h2><p><img width="300" src="https://stayawake.oss-cn-beijing.aliyuncs.com/S`1IT0{JFUM12L81CSG}D5O.png"></p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;    *{        margin: 0;        padding: 0;    }    html,body{        height: 100%;        width: 100%;    }    .box{        width: 200px;         height: 200px;        background-color: blueviolet;        margin: auto;    }   body{        display: flex;   }&lt;/style&gt;&lt;body&gt;    &lt;div class="box"&gt;        &lt;h2&gt;快速居中对齐&lt;/h2&gt;    &lt;/div&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CSS–-padding和margin有什么不同？"><a href="#CSS–-padding和margin有什么不同？" class="headerlink" title="CSS– padding和margin有什么不同？"></a>CSS– padding和margin有什么不同？</h2><p>答：作用对象不同， padding作用于自身，margin作用于外部对象</p><h2 id="CSS–-vw和百分比有什么区别？"><a href="#CSS–-vw和百分比有什么区别？" class="headerlink" title="CSS– vw和百分比有什么区别？"></a>CSS– vw和百分比有什么区别？</h2><p>答： 百分比有继承关系，vw只和设备宽度有关系</p><h2 id="如何让浏览器支持小字体？"><a href="#如何让浏览器支持小字体？" class="headerlink" title="如何让浏览器支持小字体？"></a>如何让浏览器支持小字体？</h2><p>答： 缩放</p><pre class="line-numbers language-none"><code class="language-none">transform: scale(0.8);-webkit-transform: scale(0.8);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题-浏览器跨域系列问题</title>
      <link href="/2023/01/03/qian-duan-mian-shi-ti-liu-lan-qi-kua-yu-xi-lie-wen-ti/"/>
      <url>/2023/01/03/qian-duan-mian-shi-ti-liu-lan-qi-kua-yu-xi-lie-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器跨域问题"><a href="#浏览器跨域问题" class="headerlink" title="浏览器跨域问题"></a>浏览器跨域问题</h1><h3 id="1、浏览器同源策略"><a href="#1、浏览器同源策略" class="headerlink" title="1、浏览器同源策略"></a>1、浏览器同源策略</h3><p>浏览器出于安全考虑，对<font color="red"><strong>同源请求</strong></font> 放行 ,对  <font color="red"><strong>异源请求</strong></font>  限制。</p><p>这些限制规则统称为同源策略。</p><p>因此限制造成的开发问题，称之为<strong>跨域（异源）问题</strong></p><p>何为<font color="red"><strong>同源？</strong></font></p><h3 id="源-x3D-协议-域名-端口"><a href="#源-x3D-协议-域名-端口" class="headerlink" title="源    =协议+域名+端口"></a>源    =协议+域名+端口</h3><p> <a href="http://a.com:81/">http://a.com:81</a></p><p>http –&gt;&gt;协议</p><p>a.com –&gt;&gt; 域名</p><p>81  –&gt;&gt;端口</p><p>协议+域名+端口 这三这个都相同的两个网址为同源，其他为异源</p><p>何为<font color="red"><strong>同源请求？</strong></font></p><p>这里<code>原作者</code>有个<code>笔误</code>，左边手机截图把<code>https://api.mywebsite.com</code>误写为<code>https://www.mywebsite.com</code>了，图中也有这个错误，读者要注意一下不要被误导</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/%E5%90%8C%E6%BA%90%E8%AF%B7%E6%B1%82.gif"></p><p><font color="red"><strong>异源请求</strong></font></p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/%E5%BC%82%E6%BA%90%E8%AF%B7%E6%B1%82.gif"></p><h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h2><p>浏览器如何限制？</p><p>对标签发出的跨域请求轻微限制</p><p>例如 ： link  –&gt;&gt;CSS、script –&gt;&gt; JS、img、video、audio</p><p>对  <font color="red"><strong>AJAX</strong></font>  发出的跨域请求<font color="red"><strong>严厉限制</strong></font></p><img width="500" height="300" src="https://stayawake.oss-cn-beijing.aliyuncs.com/Screenshot_20230103_140514.jpg"><p>发生ajax进行跨域，浏览器也会对服务器发送完整的请求，发生跨域问题使因为浏览器响应时浏览器会进行校验，校验不通过</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><img width="500" src="https://stayawake.oss-cn-beijing.aliyuncs.com/Screenshot_20230103_141727.jpg"><p>答案是第三个，你答对了吗？</p><h1 id="跨域问题解决方案—-CORS"><a href="#跨域问题解决方案—-CORS" class="headerlink" title="跨域问题解决方案—-CORS"></a>跨域问题解决方案—-CORS</h1><img width="500" height="300" src="https://stayawake.oss-cn-beijing.aliyuncs.com/IMG_20230103_231517.jpg"><p>跨域问题，是因为校验不通过，这个校验规则就是CORS规则</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><h6 id="CORS是一套机制用于浏览器校验跨域请求"><a href="#CORS是一套机制用于浏览器校验跨域请求" class="headerlink" title="CORS是一套机制用于浏览器校验跨域请求"></a>CORS是一套机制用于浏览器校验跨域请求</h6><h6 id="基本理念："><a href="#基本理念：" class="headerlink" title="基本理念："></a>基本理念：</h6><p>只要是服务器明确表示允许，则校验通过，</p><p>服务器明确<font color="red">拒绝</font>或<font color="red">没有表示</font>，则校验不通过。</p><p>注：（使用CORS方案的前提，必须保证服务器是[自己人]）</p><h5 id="CORS将请求分为两类："><a href="#CORS将请求分为两类：" class="headerlink" title="CORS将请求分为两类："></a>CORS将请求分为两类：</h5><h5 id="简单请求-预检请求"><a href="#简单请求-预检请求" class="headerlink" title="简单请求                                                                  预检请求"></a>简单请求                                                                  预检请求</h5><p>1、请求方式为： GET     POSTHEAD非简单请求</p><p>2、头部字段满足CORS的安全规范，详见W3C    </p><p>（粗略认知：一般不修改头部就是符合安全规范，修改之后就不符合规范）</p><p>3、请求头的Content-Type为：text/plain</p><p>​ multipart/from-data</p><p>​ application/x-www-form-urlencoded</p><p>简单请求基本过程：</p><p>浏览器发送请求，如果发现跨域，会自动携带请求头 Orgin:   http://,y.com (Orgin后通常携带的是页面源，从哪个源发送请求)，之后服务器进行验证，验证通过后，服务器有两种告诉浏览器验证通过的方法。</p><p>1、返回相应头： Access-Control-Allow-Orgin: <a href="http://my.com/">http://my.com</a> (携带一致的源) 浏览器检测源相同，校验通过</p><p>2、返回响应头：Access-Control-Allow-Orgin：* (表示所有源都通过)，浏览器校验直接通过</p><img width="500" height="300" src="https://stayawake.oss-cn-beijing.aliyuncs.com/IMG_20230103_234752.jpg"><p>预检请求基本过程：</p><p>1、发送预检请求：</p><p>浏览器发送预检请求，携带options 里面包括 Orgin ，请求方式，请求头，</p><p>服务器会返回自己允许的域，请求方式，请求头</p><img width="500" height="300" src="https://stayawake.oss-cn-beijing.aliyuncs.com/IMG_20230103_235238.jpg"><p>浏览器校验通过后，才会发送真实请求：和简单请求一样</p><p>CORS解决方案就是 服务器根据浏览器规范对相应的请求头做出相应的设置就可</p><h1 id="跨域问题解决方案—-JSONP"><a href="#跨域问题解决方案—-JSONP" class="headerlink" title="跨域问题解决方案—-JSONP"></a>跨域问题解决方案—-JSONP</h1><h3 id="JSONP-JSON-with-Padding"><a href="#JSONP-JSON-with-Padding" class="headerlink" title="JSONP     JSON   with Padding"></a>JSONP     JSON   with Padding</h3><p>JSONP是解决跨域问题额古老方案</p><p>同源策略中，对标签的跨域请求限制较小</p><p>JSONP利用这一点。</p><p><img width="500" src="https://stayawake.oss-cn-beijing.aliyuncs.com/IMG_20230108_171137.jpg"></p><p>JSONP原理：</p><p>通过script标签向服务器端发送一个get请求，服务端返回一个text/plain格式的文件，文件内容是对一个方法的调用，并回传数据，如下：</p><pre class="line-numbers language-none"><code class="language-none">callback('hello,word')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实例代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;        &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;        &lt;title&gt;Title Page&lt;/title&gt;    &lt;/head&gt;    &lt;script&gt;        function callback(resp){            console.log(resp);        }        function request(url){            const script = document.createElement('script');            script.src = url;            script.onload = function(){                script.remove();            }            document.body.appendChild(script)        }        document.querySelector('button').onclick = function(){            // 接口地址            request('http://localhost:8000/api/user');        }    &lt;/script&gt;    &lt;body&gt;       &lt;button &gt;点击获取用户&lt;/button&gt;    &lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>JSONP其实已经跟AJAX脱离关系，JQuery只是对这个函数的封装</p><p>JSONP跨域缺点：</p><ul><li>只能发送get请求，不支持post put delete</li><li>不安全，xss攻击，返回的内容可以对网站内容进行篡改</li></ul><h1 id="跨域问题解决方案—-代理"><a href="#跨域问题解决方案—-代理" class="headerlink" title="跨域问题解决方案—-代理"></a>跨域问题解决方案—-代理</h1><h3 id="跨域解决方案中-CORS和-JSONP-均对服务器有要求"><a href="#跨域解决方案中-CORS和-JSONP-均对服务器有要求" class="headerlink" title="跨域解决方案中 CORS和 JSONP 均对服务器有要求"></a>跨域解决方案中 CORS和 JSONP 均对服务器有要求</h3><p><img width="500" height="300" src="https://stayawake.oss-cn-beijing.aliyuncs.com/IMG_20230108_234712.jpg"></p><p>CORS ： 需要设置请求头</p><p>JSONP：需要服务器相应JS代码并且还需要调用方法</p><p>代理解决跨域的方式</p><p><img width="500" src="https://stayawake.oss-cn-beijing.aliyuncs.com/IMG_20230108_235200.jpg"></p><h3 id="本地启动服务解决跨域"><a href="#本地启动服务解决跨域" class="headerlink" title="本地启动服务解决跨域"></a>本地启动服务解决跨域</h3><p>前端项目在本地环境之所以能启动，是因为本地启动了一个Node服务器，我们可以让这台服务器作为代理服务器去完成请求的发送。</p><p>vue-cli本身提供了vue.config.js配置文件来配置服务器的代理，通过配置devServer可以实现这一效果：</p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/f108b8593bca5e56db3e8512807ba4fd.png"></p><p><img src="https://stayawake.oss-cn-beijing.aliyuncs.com/2fc3a77464c5edfd1cd10c9c17419b00.png"></p><p>如上图所示，在浏览器看来访问的/disease-api，是localhost:9528这个ip和端口的服务,符合同源策略，所以浏览器并不会认为这是跨域。</p><p>实际上，服务器在拦截到带有/disease-api/后，会将访问前缀更换为指定目标【target】，实际时访问的是 <a href="https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5%E3%80%82">https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5。</a></p><p>部署后的服务解决跨域</p><p>前端项目部署后，因为没有了本地的Node环境，可以通过nginx服务器来完成反向代理。</p><p>特别注意，此种情况需要服务器自身能够访问<a href="https://view.inews.qq.com/disease-api/g2/getOnsInfo?name=disease_h5%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%89%8D%E8%AF%B7%E7%A1%AE%E8%AE%A4%E3%80%82">https://view.inews.qq.com/disease-api/g2/getOnsInfo?name=disease_h5，使用前请确认。</a></p><h1 id="跨域经典场景"><a href="#跨域经典场景" class="headerlink" title="跨域经典场景"></a>跨域经典场景</h1><p><img width="500" height="500" src="https://stayawake.oss-cn-beijing.aliyuncs.com/IMG_20230109_000755.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NProgress使用笔记</title>
      <link href="/2022/12/27/nprogress-shi-yong-bi-ji/"/>
      <url>/2022/12/27/nprogress-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="NProgress使用笔记"><a href="#NProgress使用笔记" class="headerlink" title="NProgress使用笔记"></a>NProgress使用笔记</h1><p>关于在vue项目中使用Nprogress来显示页面顶部的进度条笔记</p><h4 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h4><p><a href="https://github.com/rstacruz/nprogress">https://github.com/rstacruz/nprogres</a></p><h4 id="演示网站"><a href="#演示网站" class="headerlink" title="演示网站"></a>演示网站</h4><p><a href="https://ricostacruz.com/nprogress/">https://ricostacruz.com/nprogress/</a></p><h2 id="安装-基本用法"><a href="#安装-基本用法" class="headerlink" title="安装+基本用法"></a>安装+基本用法</h2><pre class="line-numbers language-none"><code class="language-none">// 下载安装npm i nprogress -S// 基本用法NProgress.start();NProgress.done();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><h5 id="递增："><a href="#递增：" class="headerlink" title="递增："></a>递增：</h5><p>要递增进度条，只需使用  .inc() 。这使它以随机量递增。这将永远不会达到100%； 将其用于每次图片加载（或类似加载）。</p><pre class="line-numbers language-none"><code class="language-none">NProgress.inc();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="如果要添加特定值，可以将其作为参数传递："><a href="#如果要添加特定值，可以将其作为参数传递：" class="headerlink" title="如果要添加特定值，可以将其作为参数传递："></a>如果要添加特定值，可以将其作为参数传递：</h5><pre class="line-numbers language-none"><code class="language-none">NProgress.inc(0.2);  //这将获取当前状态值并添加0.2直到状态为0.994<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PS:我的理解：及每次增加一点点，但永远不会到100%</p><h4 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h4><h5 id="easing-和-speed"><a href="#easing-和-speed" class="headerlink" title="easing 和 speed"></a>easing 和 speed</h5><p>使用缓动（CSS缓动字符串）和速度（以豪秒为单位）调整动画设置。（默认： ease和 200）</p><pre class="line-numbers language-none"><code class="language-none">NProgress.configure({ easing:'ease',speed: 500});<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="showSpinner"><a href="#showSpinner" class="headerlink" title="showSpinner"></a>showSpinner</h5><p>通过将加载微调器设置为false 来关闭它。（默认值：true）</p><pre class="line-numbers language-none"><code class="language-none">Nprogress.configure({showSpinner:false})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="minimum"><a href="#minimum" class="headerlink" title="minimum"></a>minimum</h5><p>更改启动时使用最小的百分比（默认：0.08）</p><pre class="line-numbers language-none"><code class="language-none">NProgress.configure({minimum:0.1});<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="template"><a href="#template" class="headerlink" title="template:"></a>template:</h5><p>可以使用template 更改标记，若要使进度条保持工作，请将元素role=’bar’保留在那里，<a href="https://github.com/rstacruz/nprogress/blob/master/nprogress.js">默认模板</a>以进行参考</p><pre class="line-numbers language-none"><code class="language-none">NProgress.configure({template:"&lt;div class="..."&gt;...&lt;/div&gt;"})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="trickle"><a href="#trickle" class="headerlink" title="trickle"></a>trickle</h5><p>将其设置为false 关闭自动递增行为（默认：true）</p><pre class="line-numbers language-none"><code class="language-none">NProgress.configure({trickle:false})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h5><p>指定此选项以更改父容器（默认：body）</p><pre class="line-numbers language-none"><code class="language-none">NProgress.configure({parent:'#container'})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="在vue项目中使用"><a href="#在vue项目中使用" class="headerlink" title="在vue项目中使用"></a>在vue项目中使用</h4><h4 id="引入NProgress默认样式"><a href="#引入NProgress默认样式" class="headerlink" title="引入NProgress默认样式"></a>引入NProgress默认样式</h4><p>在 ~/main.js中引入Nprogress默认样式</p><pre class="line-numbers language-none"><code class="language-none">//引入进度条样式import 'nprogress/nprogress.css'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它默认显示蓝色进度条，如果你想自定义进度条颜色可在全局css中或在app.vue下写入自己自定义的css样式；</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;//自定义进度条颜色#nprogress .bar{background: #F811B2 !important;}&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在页面切换中使用"><a href="#在页面切换中使用" class="headerlink" title="在页面切换中使用"></a>在页面切换中使用</h5><p>在 ~/router/index.js 【路由配置】文件中：</p><pre class="line-numbers language-none"><code class="language-none">import Vue from 'vue'import VueRouter from 'vue-router'//引入nprogress进度条插件import NProgress from 'nprogress'Vue.use(VueRouter);//简单配置进度条，可以不配置： 在axios中我们不再做配置，以用来区分。NProgess.inc(0.2)NProgress.configure({easing:'ease',speed:500,showSpinner:false})esport const constRouter=[{        path: '/login',        component: () =&gt; import('@/views/login/Login'),    },    ...]const rputer = new VueRouter({mode: 'history',base: process.env.BASE_URL,routes: constRouter})//页面路由刚开始切换的时候router.beforeEach(async (to,from,next)=&gt;{// 开启进度条    NProgress.start();})//页面路由切换完毕的时候router.afterEach(()=&gt;{//关闭进度条NProgress.done()})export default router<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在接口请求中使用"><a href="#在接口请求中使用" class="headerlink" title="在接口请求中使用"></a>在接口请求中使用</h4><p>在 ~/api/index.js 【axios请求配置】文件中：</p><pre class="line-numbers language-none"><code class="language-none">import axios from 'axios'//引入nprogress进度条插件import NProgress from 'nprogress'//创建axios实例const service = axios.create({    baseURL: process.env.VUE_APP_BASE_API, //URL地址   环境变量文件    timeout: 5000 ,//超时})// 请求拦截器service.interceptors.request.use(    config =&gt; {    // 开启进度条NProgress.start();        return config    },    error =&gt; {        return Promise.reject(error)    })// 响应拦截器service.interceptors.response.use(    response =&gt;{        // 关闭进度条        NProgress.done()    return Promise.reject(response)    },    error =&gt; {        // 关闭进度条        NProgress.done()        return Promise.reject(error)    })export default service;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端开源插件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
